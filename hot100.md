- [\[数组\] 1.两数之和](#数组-1两数之和)
- [\[链表\] 2.两数相加](#链表-2两数相加)
- [\[字符串\] 3.无重复字符的最长子串（的长度）](#字符串-3无重复字符的最长子串的长度)
- [\[数组\] 4.寻找两个正序数组的中位数 TODO](#数组-4寻找两个正序数组的中位数-todo)
- [\[字符串|中心扩散法\] 5.最长回文子串](#字符串中心扩散法-5最长回文子串)
- [\[数组\] 11.盛最多水的容器](#数组-11盛最多水的容器)
- [\[数组\] 15.三数之和](#数组-15三数之和)
- [\[字符串|回溯\] 17.电话号码的字母组合](#字符串回溯-17电话号码的字母组合)
- [\[链表\] 19.删除链表的倒数第N个节点](#链表-19删除链表的倒数第n个节点)
- [\[数组|栈\] 20.有效的括号](#数组栈-20有效的括号)
- [\[链表\] 21.合并两个有序链表](#链表-21合并两个有序链表)
- [\[回溯\] 22.括号生成](#回溯-22括号生成)
- [\[链表数组\] 24.合并K个升序链表](#链表数组-24合并k个升序链表)
- [\[数组\] 31.下一个排列](#数组-31下一个排列)
- [\[字符串\] 32.最长有效括号 TODO](#字符串-32最长有效括号-todo)
- [\[数组|二分查找\] 33.搜索旋转排序数组](#数组二分查找-33搜索旋转排序数组)
- [\[数组|二分查找\] 34.在排序数组中查找元素的第一个和最后一个位置](#数组二分查找-34在排序数组中查找元素的第一个和最后一个位置)
- [\[数组|回溯+剪枝\] 39.组合总和](#数组回溯剪枝-39组合总和)
- [\[数组\] 42.接雨水 TODO](#数组-42接雨水-todo)
- [\[数组|全排列|回溯\] 46.全排列](#数组全排列回溯-46全排列)
- [\[二维数组\] 48.旋转图像](#二维数组-48旋转图像)
- [\[数组|动态规划\] 53.最大字数组和（的值）](#数组动态规划-53最大字数组和的值)
- [\[链表\] 83.删除排序链表中的重复元素](#链表-83删除排序链表中的重复元素)
- [\[数组\] 88.合并两个有序数组](#数组-88合并两个有序数组)
- [\[树\] 94.二叉树的中序遍历](#树-94二叉树的中序遍历)
- [\[树\] 102.二叉树的层序遍历](#树-102二叉树的层序遍历)
- [\[树\] 104.二叉树的最大深度](#树-104二叉树的最大深度)
- [\[链表\] 141.环形链表](#链表-141环形链表)
- [\[链表\] 206.反转链表](#链表-206反转链表)
- [\[链表\] 237.删除链表中的节点](#链表-237删除链表中的节点)
- [\[数组\] 322.零钱兑换 TODO](#数组-322零钱兑换-todo)
- [\[数组|队列\] 933.最近的请求次数](#数组队列-933最近的请求次数)

### [数组] 1.两数之和 
> <https://leetcode.cn/problems/two-sum/>

```
1. 推荐方法一：利用 [哈希表] 减少再次遍历匹配
2. 拓展之ES6 Map的使用，特殊在于key可以是对象
    - size 属性
    - get(key)
        - 返回对应的值
    - set(key, value)
        - 注意：重复key会覆盖
        - 返回当前 Map 对象，因此可以链式调用
    - has(key): boolean
    - delete(key): boolean
    - clear(): void 清空
```

```TypeScript
/**
 * 方法一: 哈希表 [推荐，更优解] 只遍历一次
 * 
 * 时间复杂度 O(n)，空间复杂度 O(n) 哈希表开销
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 1. 初始化一个map<key, value>，key是数值，value是下标
    let map = new Map();

    /**
     * 2. 遍历每一个值：先找是否已有符合条件的另一个值在map中，有则直接返回，无则放入继续遍历
     */
    for (let i = 0; i < nums.length; i++) {
        // 找差值，也就是另一个数
        let otherValue = target - nums[i];
        if (map.has(otherValue)) {
            return [map.get(otherValue), i];
        } else {
            // 未找到符合条件的，先放入元素，继续遍历
            map.set(nums[i], i);
        }
    }
    // 未找到，返回空数组
    return [];
};
```
```TypeScript
/**
 * 方法二: 暴力枚举
 * 
 * 时间复杂度 O(n^2)，空间复杂度 O(1)
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 双层遍历，直接看 num1 + num2 是否等于 target
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            // 里层遍历不需要从头遍历了
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
};
```
```TypeScript
/**
 * 思路三: 双指针
 * 
 * ！！！先说一下这道题不适合：因为这个数组不是有序的，如果排序后使用下标已经变化了；但是可以列一下这个思路
 * 如果题干指明是一个有序数组的话，双指针可以分别从首位出发，利用和判断是移动左还是右指针，在指针相遇之前找到合适的两个数
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
```
<br/>



### [链表] 2.两数相加 
> <https://leetcode.cn/problems/add-two-numbers/>

```
1. 注意链表新增节点的方式，遍历链表一般都是用while配合指针的移动，最后方法返回的是链表头结点
2. 两数相加一些老写的东西：
    - sum % 10，取模，计算出来的是个位数值，比如 (7+8) % 10 = 5
    - Math.floor(sum/10) 是计算进制位，Math.floor(15/10) = 1

    总是记不清的话：数学里面除法是一条横的杠，这里换成斜的
```

```javascript
/**
 * 仔细观察就能看到，因为链表是逆序，所以直接链表从头结点开始进行相加进位即可
 * 需要注意的一个小点是对最后一位的处理
 * 
 * 时间复杂度 O(max(m,n))：m/n 分别为两个链表的长度，因为遍历链表的每个位置需要 O(1) 的时间
 * 空间复杂度 O(1) 返回值不计入空间复杂度
 * 
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    // 初始化结果链表的头结点、尾/当前节点
    let head = null, current = null;
    // 进制位
    let k = 0;

    // 遍历完两个链表无论谁长谁短
    while (l1 || l2) {
        let val1 = l1 ? l1.val || 0 : 0;
        let val2 = l2 ? l2.val || 0 : 0;

        // 算和
        let sum = val1 + val2 + k;

        // 计算进制，下一次计算时使用
        // k = (sum > 10) ? 1 : 0;
        k = Math.floor(sum / 10);

        // 取模，得到该节点的值；比如 7+8，value=5
        let value = sum % 10;
        // 新链表，无头结点
        if (!head) {
            head = current = new ListNode(value);
        } else {
            // 新增链表节点，移动指针
            current.next = new ListNode(value);
            current = current.next;
        }

        // 移动链表指针
        l1 = l1 && l1.next;
        l2 = l2 && l2.next;
    }

    // 链表结束遍历后处理可能的最后一位
    if (k > 0) {
        current.next = new ListNode(k);
    }

    // 返回链表头结点
    return head;
};

```
<br/>



### [字符串] 3.无重复字符的最长子串（的长度）
> <https://leetcode.cn/problems/longest-substring-without-repeating-characters/>

```
1. 滑动窗口的应用，不仅限于这道题
2. 拓展补充 ES6 Set
    - size属性
    - add(value)
    - delete(value): boolean
    - has(value): boolean
    - clear()
3. 字符串获取某个位置上的字符：str.charAt(index)
```

```javascript
/**
 * 滑动窗口
 *  遍历每一个元素为其找到最大长度窗口（使用两个指针移动窗口），在每一次遍历后更新最大长度
 * 
 *  时间复杂度 O(n)
 * 
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    // 滑动窗口的右指针，左指针就是遍历字符串的指针
    let right = 0;
    // 最长长度，在针对每一个元素的窗口滑动之后都会去重新取新的最大值
    let max = 0;
    // 辅助判断是否有相同字符出现
    let set = new Set();

    // 依次遍历，找每一个元素的最大滑动窗口
    for (let left = 0; left < s.length; left++) {
        // 只要右指针未越界，元素未重复，就移动右指针并添加元素
        while (right < s.length && !set.has(s.charAt(right))) {
            set.add(s.charAt(right));
            right++;
        }
        // 重新计算最大长度
        max = Math.max(max, right - left);
        // 遍历结束，移除最左侧字符
        set.delete(s.charAt(left));
    }

    return max;
};
```
<br/>



### [数组] 4.寻找两个正序数组的中位数 TODO
> <https://leetcode.cn/problems/median-of-two-sorted-arrays/>

```

```

```javascript

```
<br/>



### [字符串|中心扩散法] 5.最长回文子串
> <https://leetcode.cn/problems/longest-palindromic-substring/>

```
1.首先先搞清楚 [回文子串] 是啥再答题：
    - 回文串是从左到右读和从右到左读都一样的字符串，有轴对称的特点
    - 子串：是指原始字符串的一个 [连续] 子集
        - 子序列：原始字符串的一个子集
2.这里只写了中心扩散法，还有其他方法：
    - 动态规划法（这个还挺常规解法的，但是我看不懂，之后再补吧）
    - Manacher算法（这个有难度）
```

```javascript
/**
 * 中心扩散法：
 *  [思想]:
 *      1. 遍历字符串的每一个字符，并将其作为子串的中点字符即中心，
 *      2. 以当前字符为中心向两边扩散：查找偶数回文子串和奇数回文子串
 *          2.1 偶数子串的中心位是2个数
 *          2.2 奇数子串的中心位是1个数
 *      3. 比较更新最大长度，记录中心位置下标
 *      4. 完成遍历后截取字符串（这个操作在确定了最长子串中心位后再整个方法最后执行就行，因为比较耗时）
 * 
 *  [注意]：中间那个分别求奇/偶回文子串其实也可以写成两个 while 分别算一下，然后比较最长长度再更新起始位置
 *          这样写的优势在于不用在计算起始位置时找规律
 * 
 * 
 *  时间复杂度 O(n^2) 空间复杂度 O(1)
 * 
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
    // 0.特殊判断
    let len = s.length;
    if (len < 2) return s;

    // 1. 初始化最长长度和子串开始位置下标
    let maxLen = 0;
    let begin = 0;

    // 2. 只需要判断到倒数第二个为止的元素即可
    for (let i = 0; i < len - 1; i++) {
        // 3.1 奇数回文串最长长度
        let [oddLen, oddLeft] = expandAroundCenter(s, i, i);
        // 3.2 偶数回文串最长长度
        let [evenLen, evenLeft] = expandAroundCenter(s, i, i + 1);

        // 4. 更新最长长度和子串起始下标
        let curMaxLen = Math.max(oddLen, evenLen);
        if (curMaxLen > maxLen) {
            maxLen = curMaxLen;
            begin = oddLen > evenLen ? oddLeft : evenLeft;
            // // 这里奇数偶数都可以用这个算式计算出起始位置， / 用来向下取整；
            // 不过我始终没明白怎么算出来的，所以我在辅助函数里直接返回回来
            // begin = i - (maxLen - 1) / 2;
        }
    }

    // 5. 截取字符串返回
    return s.slice(begin, begin + maxLen);
};

/**
 * 
 * 辅助函数：
 *  1.以传入的中心位下标，开始两边扩散找回文串，有两种情况：
 *    不过无论是哪种，第一步都可以直接进行左右比较，然后开始左右拓展
 *      1.1 -> left=right，中心位是同一个下标的元素，所以要找的是奇数回文串
 *      1.2 -> right=left+1，中心位是两个，找的是偶数回文串
 *  2.左右匹配相同就移动指针，一直到不相同了就退出 while 循环 (break 也可以退出 while 循环)
 *  3.返回子串长度和子串开始位置
 * 
 * @param s 字符串
 * @param left 左中心位下标
 * @param right 右中心位下标
 * @returns [length, begin]
 */
function expandAroundCenter(s, left, right) {
    while (left >= 0 && right < s.length && s.charAt(left) === s.charAt(right)) {
        left--;
        right++;
    }
    return [right - left - 1, left + 1];
}
```
<br/>



### [数组] 11.盛最多水的容器
> <https://leetcode.cn/problems/container-with-most-water/>

```
- 理解题目：计算的盛水最多容器其实就是计算矩形面积的最大值，计算公式就是距离*min(h1,h2)
- 解题要点：双指针
- 解法：
    1.[双指针] 此题最优解：
        因为要计算的是矩形面积，
        而面积更大的条件无非是在控制一边的情况下，另一边越大越有可能成为更大的容器。
        所以基于这个想法移动短的边，寻找可能的更大面积，同样也是保留计算过程中的最大面积。
    2.[暴力解法] 没什么好说，依次计算所有面积，保留最大面积（这个提交没通过，超时了）
```

```javascript
/**
 * [双指针法] 此题最优解：
    因为要计算的是矩形面积，
    而面积更大的条件无非是在控制一边的情况下，另一边越大越有可能成为更大的容器。
    所以基于这个想法移动短的边，寻找可能的更大面积，同样也是保留计算过程中的最大面积。
 *  
 * 时间复杂度 O(n) 空间复杂度 O(1)
 * 
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let maxArea = 0;
    let len = height.length;
    let j = len - 1; //初始化右侧指针

    for (let i = 0; i < len - 1; i++) {
        // 两个指针相遇作为结束条件
        while (i < j) {
            maxArea = Math.max(
                maxArea,
                (j - i) * Math.min(height[i], height[j])
            );
            // 比较两边值的大小，移动更小的那一边，寻求更大面积解
            (height[i] > height[j]) ? j-- : i++;
        }
    }
    return maxArea;
};
```

```javascript
/**
 * 暴力解法：
 *  两次循环依次计算盛水面积，保留最大值
 * 
 * 时间复杂度 O(n^2) 空间复杂度 O(1)
 * 
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let len = height.length;
    let maxArea = 0;
    for (let i = 0; i < len - 1; i++) {
        for (let j = i + 1; j < len; j++) {
            maxArea = Math.max(maxArea, (j - i) * Math.min(height[i], height[j]));
        }
    }
    return maxArea;
};
```
<br/>



### [数组] 15.三数之和
> <https://leetcode.cn/problems/3sum/>

```javascript
/**
 * 排序+双指针：
 * 
 *  先进行排序，然后开始遍历，相当于是固定第一个元素，然后找两数之和，所以用了双指针缩小范围
 *  需要注意的就是去重的操作：
 *   1.第一个是在遍历时如果遇到与上一个遍历相同的元素，就直接跳过当次循环
 *   2.第二个是在为某一个元素找到一组解之后，继续制动指针找其余解，加了一层判断，确保移动到不同值上
 * 
 *  时间复杂度 O(n^2)：排序复杂度是 O(N logN)，但是循环是 O(n^2)，因此总的时间复杂度 O(n^2)
 * 
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
    let result = [];
    // 从小到大排序
    nums.sort((a, b) => a - b);
    // 依次遍历
    for (let i = 0; i < nums.length - 2; i++) {
        // 因为按序排列，当最小数已经大于0时就可以直接退出循环了
        if (nums[i] > 0) break;
        // 比对是否与上一个数值相同，达到去重目的
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        // 初始化双指针
        let left = i + 1;
        let right = nums.length - 1;
        while (left < right) {
            if (nums[i] + nums[left] + nums[right] === 0) {
                // 找到了其中一组解
                result.push([nums[i], nums[left], nums[right]]);
                // 移动指针
                left++;
                right--;
                // 判断移动后指针所指元素是否与上一个元素相同，相同则继续移动，避免重复元素
                while (left < right && nums[left] === nums[left - 1]) left++;
                while (left < right && nums[right] === nums[right + 1]) right--;
            } else {
                // 与0做比较决定移动哪一个指针
                (nums[left] + nums[right] + nums[i]) > 0 ? right-- : left++
            }
        }
    }
    return result;
};
```
<br/>



### [字符串|回溯] 17.电话号码的字母组合
> <https://leetcode.cn/problems/letter-combinations-of-a-phone-number/>

```
1.使用回溯法：
    在图上画一下这个题的思路之后会发现很像树，
    所以我们沿着其中一个节点一直遍历找到它对应的字符串，直到没有节点了
    就可以把这个路径字符串添加到结果集当中了

    这个过程中每一个都是在当前路径字符串上添加结果，
    直到全部遍历结束了才添加到结果集中
```

```javascript
/**
 * 回溯法：
 *  有点像树，沿着一条路径深度遍历直到没有数字了
 * 
 *  时间复杂度 O(3^m * 4^n)：
 *  1. 其中m是输入中对应3个字母的数字个数（包括数字 2、3、4、5、6、8）
 *  2. n是输入中对应4个字母的数字个数（包括数字 7、9）
 * 
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
    if (digits.length === 0) return [];

    // 用哈希表存储按键对应的字母
    let map = new Map([
        ['2', 'abc'],
        ['3', 'def'],
        ['4', 'ghi'],
        ['5', 'jkl'],
        ['6', 'mno'],
        ['7', 'pqrs'],
        ['8', 'tuv'],
        ['9', 'wxyz']
    ]);

    // 结果集数组
    let res = [];
    // 回溯
    backtrack('', digits);
    return res;

    /**
     * 回溯函数
     * @param {*} curstr 当前路径已经拼接好的字符串
     * @param {*} digits 剩余字符串
     */
    function backtrack(curstr, digits) {
        if (digits.length === 0) {
            // 当前路径遍历结束了，将路径放入结果集
            res.push(curstr);
        } else {
            let str = map.get(digits.charAt(0)); //每次都取最前面的数字，去map中映射其字母
            for (let i = 0; i < str.length; i++) {
                // 拼接好当前路径，删掉当前处理的数字字符，继续回溯
                backtrack(curstr + str.charAt(i), digits.slice(1));
            }
        }
    }
};
```
<br/>



### [链表] 19.删除链表的倒数第N个节点
> <https://leetcode.cn/problems/remove-nth-node-from-end-of-list/>

```
1.进行链表操作时，常用的一个技巧是添加一个哑节点
  它的next指针指向链表头结点，这样就不需要对头结点进行特殊判断了
2.方法：
    2.1 遍历计算链表长度；再次遍历删除对应节点
    2.2 栈结构 []
        - push() 入栈
        - pop() 出栈，得到出栈元素
    2.3 快慢指针[推荐] *
```

```javascript
/**
 * 方法一：计算链表长度
 *  先遍历一遍获取长度，再遍历一遍删除节点
 * 
 * 时间复杂度 O(n) n是链表长度
 * 空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    let first = new ListNode(0, head);
    // 统计链表长度
    let len = 0;
    while (head.next) {
        head = head.next;
        len++;
    }
    // 再次遍历，遍历至要删除的节点之前
    let cur = first;
    for (let i = 0; i < len - n + 1; i++) {
        cur = cur.next;
    }
    // 修改指针next
    cur.next = cur.next.next;
    return first.next;
};
```

```javascript
/**
 * 方法二：栈方法
 *  将所有节点元素都进栈，然后出栈倒数n个节点元素得到删除节点的前一个节点
 *  
 *  时间复杂度 O(n) 
 *  空间复杂度 O(n) 栈的开销
 * 
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    // 添加哑节点，指向链表第一个节点
    let first = new ListNode(0, head);
    let stack = []; //栈
    let cur = first;
    // 依次进栈
    while (cur !== null) {
        stack.push(cur);
        cur = cur.next;
    }
    // 出栈倒数n个节点
    for (let i = 0; i < n; ++i) {
        stack.pop();
    }
    // 得到要删除的节点的前一个节点，重新设置next指针
    let prev = stack.pop();
    prev.next = prev.next.next;
    // 返回头结点
    return first.next;
};
```

```javascript
/**
 * 方法三：双指针 快慢指针
 *  
 *  时间复杂度 O(n) 
 *  空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    // 添加哑节点，指向链表第一个节点
    let first = new ListNode(0, head);
    let slow = first;
    let fast = first;
    // 快指针先走n步
    for (let i = 0; i < n; i++) {
        fast = fast.next;
    }
    // 快慢指针一起走
    while (fast.next !== null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return first.next;
};
```
<br/>



### [数组|栈] 20.有效的括号
> <https://leetcode.cn/problems/valid-parentheses/>

```javascript
/**
 * 解法：栈
 *  左括号入栈，右括号与栈顶匹配
 *  不是一对就返回false，是一对完成出栈
 * 
 * 时间复杂度 O(n)
 * 
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
    // 特判，奇数个必不可能有效
    if (s.length % 2 === 1) return false;
    // 符号映射关系
    let map = new Map();
    map.set(")", "(");
    map.set("]", "[");
    map.set("}", "{");
    // 栈
    let stack = [];
    for (let i = 0; i < s.length; i++) {
        if (!map.get(s.charAt(i))) {
            // 左半边，入栈
            stack.push(s.charAt(i));
        } else {
            // 右半边，看栈顶是否是一对
            if (stack[stack.length - 1] !== map.get(s.charAt(i))) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.length === 0;
};
```
<br/>



### [链表] 21.合并两个有序链表
> <https://leetcode.cn/problems/merge-two-sorted-lists/>

```
1. 方法，两者都是循环
    1.1 迭代：
        与普通循环不同点在于，迭代计算一次后的变量结果是下一次循环的初始值
        然后根据这个变量的变化去进行下一步的计算
    1.1 递归：
        自己调用自己，然后在一定的条件下停止并返回结果给上一个调用
        借助栈实现，每次的调用都会被压入栈直到达成退出条件，然后执行出栈
```

```javascript
/**
 * 方法一：迭代
 * 
 *  时间复杂度 O(m+n)
 *  空间复杂度 O(1)
 * 
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
    // 特判
    if (list1 === null) return list2;
    if (list2 === null) return list1;

    // 哑节点
    let head = new ListNode(0);
    let cur = head;

    while (list1 !== null && list2 !== null) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    // 合并后两个链表最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    cur.next = (list1 === null) ? list2 : list1;
    return head.next;
};
```

```javascript
/**
 * 方法二：递归
 *  
 *  思路就是不停的调用自身寻找两者中的更小节点并进行指针改变，
 *  注意要把结果返回回去
 * 
 *  时间复杂度 O(m+n)
 *  空间复杂度 O(m+n) 栈的开销
 * 
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
    if (list1 === null) {
        return list2;
    } else if (list2 === null) {
        return list1;
    } else if (list1.val <= list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
    } else {
        list2.next = mergeTwoLists(list1, list2.next);
        return list2;
    }
};
```
<br/>



### [回溯] 22.括号生成
> <https://leetcode.cn/problems/generate-parentheses/>

```
1.采用回溯法，感觉回溯法的写法有一丢丢像的，可以结合 (17、46) 题一起看看
    思路就是依次探索可以放左右括号的路径，直到左右括号被放完
    这个其实也可以用树的方式画出来解题思路
```

```javascript
/**
 * 回溯法
 * 
 * [思路]：
 *  因为括号是成对出现的，所以左括号数=右括号数=n
 *  初始化结果集，回溯过程就是依次找可能的结果直到n=0，然后放入结果集
 *  这个过程中，已有的左括号一定不能比右括号少，不然就不是有效括号了
 * 
 * 
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
    if (n === 0) return [];
    let res = []; //结果集
    backtrack('', n, n);
    return res;

    /**
     * 回溯函数
     * 
     * @param {*} cur 当前可能的结果（不一定完整）
     * @param {*} left 当前剩余左括号数量
     * @param {*} right 当前剩余右括号数量
     * @returns 
     */
    function backtrack(cur, left, right) {
        if (left === 0 && right === 0) {
            // 左右括号都放完了，放入结果集
            res.push(cur);
            return;
        }
        if (left === right) {
            // 左右括号数目相同，下一个必须放左括号
            backtrack(cur + '(', left - 1, right);
        } else if (left < right) {
            // 只要保证左边括号比右边多就好了，这种情况下，放左/右都行
            if (left > 0) {
                backtrack(cur + '(', left - 1, right);
            }
            if (right > 0) {
                backtrack(cur + ')', left, right - 1);
            }
        }
        // 没有right>left分支，因为那样括号无效了
    }
};
```
<br/>



### [链表数组] 24.合并K个升序链表
> <https://leetcode.cn/problems/merge-k-sorted-lists/>

```
方法一：按顺序两两合并
方法二：分治，(其实是没特别理解)
方法三：暴力法-数组(没写)
    将所有元素到一个数组中，然后对数组排序，再根据数组进行链表生成
    时间复杂度 O(NlogN) 这个是排序的时间
    空间复杂度 O(N)
```

```javascript
/**
 * 方法一：顺序合并
 *  按序，前后两两合并
 * 
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {
    let head = null;
    for (let i = 0; i < lists.length; i++) {
        head = sortTwoList(head, lists[i]);
    }
    return head;
};

function sortTwoList(list1, list2) {
    let head = new ListNode();
    let cur = head;
    while (list1 !== null && list2 !== null) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    cur.next = (list1 === null) ? list2 : list1;
    return head.next;
}
```

```javascript
/**
 * 方法二：分治
 * 
 * 时间复杂度 O(nlogk) k为链表总数 n为合并两个链表所用时间
 * 
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {
    let n = lists.length;
    if (n == 0) return null;
    // 合并两个链表
    let mergeTwoLists = (l1, l2) => {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val <= l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
    let merge = (left, right) => {
        if (left == right) return lists[left];
        let mid = (left + right) >> 1; //相当于 /2
        let l1 = merge(left, mid);
        let l2 = merge(mid + 1, right);
        return mergeTwoLists(l1, l2);
    }
    return merge(0, n - 1);
};
```
<br/>



### [数组] 31.下一个排列
> <https://leetcode.cn/problems/next-permutation/>
> 
> 官方不好直接理解。推荐这个
> [精选贴](https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/)
> ，更好理解实现思路，折线图示讲解真是茅塞顿开。

```
[解题思路] 
    这个题主要在于思维，首先审题意，更好理解的方式是将它们转换为以下描述：
    给定若干数字，使其组合成为一个整数，如何排列数字以得到下一个更大的整数；如果没有更大整数则输出最小的整数

    换成数字就比较好理解了，要找的其实是比当前数更大的数字排列里最小的那一个，也就是尽可能小的更大值
    也就是说要满足两个条件：
    1.比当前大
        满足这个条件，只需要将 [后面的大数与前面的小数] [交换] 即可得到更大的数
        这个很好理解，同位数位置上数字越大那么数值也就越大（个位、十位、百分位）
    2.增幅最小
        因为找的是邻近的下一个排列，因此增幅要保证是最小，为了达成这个条件，在上面的基础上分析一下：
        2.1 首先从[小数]控制：找尽可能靠右也就是尽可能在低位的数字作为小数
        2.2 然后控制[大数]：找尽可能小的大数，以保证增幅最小
        2.3 找到并交换两个数字后，将大数之后的数字升序排列，保证后面数字是最小的排列
        
[代码思路]
    1. 如何找到要交换的[小数]，这块我是反应半天才反应过来的，主要是看精选里画的折线图明白的
        要从后向前找第一个相邻升序元素对，为什么呢？
        首先从后向前找这个点不需要多说，保证增幅最小，需要从后向前找；然后我们做个假设：
        如果后面数字序列是降序的，比如 xxx852，那么比 852 更大的数字其实是没有的，下一个排列是最小数了
        排除这种特殊情况，我们要找的是会产生更大值的拐点，也就是这个[小数]
        其实看折线图很好理解，只要是找到第一个相邻升序元素就有更大值的可能
            1.1 找到小数
            1.2 特殊情况：没找到符合条件的，也就是说数字是全降序排列，直接反转整个数组，退出函数
    2. 找大数的思路就比较清晰了，要在小数的右侧找尽可能小的大数
        因为右侧是倒序排列，所以从后向前找到第一个大于小数的数即为[大数]
    3. 找到之后交换[小数]与[大数]；
    4. 为了保证数值是最小增幅，对大数后面排列进行升序处理（更高位数字更小数值更小）
```

```javascript
/**
 * 代码实现就参照代表实现思路按点看就行
 * 
 *  1. 找小数和找大数的遍历代码实现只要一个指针就够，好好看一下
 *     一开始自己写的实现复杂了
 *  2. 注意边界问题，主要是值相等的情况
 * 
 *  时间复杂度 O(n)
 *  空间复杂度 O(1)
 * 
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function (nums) {
    let len = nums.length;

    let small = len - 2; //小数小标，初始化为倒数第二个元素下标
    // 1. 找小数：从后向前
    while (small >= 0 && nums[small] >= nums[small + 1]) {
        small--;
    }

    // 1.2 找完发现没有找到符合条件的，说明是最大排列，直接反转整个数组
    if (small < 0) return nums.reverse();

    // 2. 找大数，从后向前找到第一个比小数大的数
    let big = len - 1; //大数下标，初始化为数组最后一个元素
    while (big > small && nums[big] <= nums[small]) {
        big--;
    }

    // 3. 交换大小数
    swap(small, big);

    // 4. 从小数坐标往右开始反转数组
    small++;
    let end = len - 1;
    while (small < end) {
        swap(small++, end--);
    }

    function swap(i, j) {
        let tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
};
```
<br/>



### [字符串] 32.最长有效括号 TODO
> <https://leetcode.cn/problems/longest-valid-parentheses/>

```
```

```javascript

```
<br/>



### [数组|二分查找] 33.搜索旋转排序数组
> <https://leetcode.cn/problems/search-in-rotated-sorted-array/>

```
[思路]
    1. 时间复杂度要求 O(logN)，所以该想到使用二分法解决
    2. 使用二分法划分数组后，根据旋转排序数组特性，一定有一边是有序另一边是无序的
       判断是否有序可以看边界值的对比；
       始终在有序的一边利用有序特征进行判定，得出下一次二分是在左边还是右边也就是移动左指针/右指针
[注意点]
    1. 位运算 n>>1 相当于 Math.floor(n/2) 二分向下取整
    2. 注意移动指针时因为已经判断了mid位置，所以l/r要+/-1
```

```javascript
/**
 * 二分查找：
 * 
 *  时间复杂度 O(logN)
 * 
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
    let l = 0;
    let r = nums.length - 1;

    while (l <= r) {
        let mid = (r + l) >> 1;
        if (nums[mid] === target) return mid;
        if (nums[l] <= nums[mid]) { //这里要注意是 <=，不是 <
            // 前半部分即左边是有序的
            if (target >= nums[l] && target <= nums[mid]) { //在有序这边即左边，移动右指针
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        } else {
            // 后半部分是有序的
            if (target >= nums[mid] && target <= nums[r]) { //在右边，移动左指针
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
    }
    return -1;
};
```
<br/>



### [数组|二分查找] 34.在排序数组中查找元素的第一个和最后一个位置
> <https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/>

```
[思路]
    1. 时间复杂度要求 O(logN)，想到使用二分法解决
    2. 这个题目标元素可能出现不止两次，要找的是开始位置和结束位置
[解法]
    1. 解法一：
        官网讲解视频版本，分别找开始和结束的位置；代码量比较大
    2. 解法二 [推荐]：（看我写的这个写法吧，官网代码版本有点搞麻烦了）
        优化，代码复用版本，分别找
        - 第一个 >=target 的位置即 [开始位置]
        - 第一个 >= target+1 的位置即 [结束位置的后一位/结束位置]
            - 其实就是 > target 的第一个位置，存在没找到的情况，看注解
```

```javascript
/**
 * 解法一：官网视频版：分别找开始和结束的位置
 * 
 * 思路：二分查找
 *  这个题其实就是利用二分查找，分别找开始和结束位置
 *  所以我们分别写两个函数用来找这两个位置
 *  其中与中间元素判断时条件划分细致，有开闭区间之分，很细节，细品
 *  
 *  查找的两个函数其实分支是一样的，只是变动的指针不同
 *  主要代码 *** 的地方
 * 
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function (nums, target) {
    // 特判
    if (nums.length === 0) return [-1, -1];

    let start = findFirstPosition(nums, target);
    // 如果开始位置都没找到，说明不存在，返回 [-1, -1]
    if (start === -1) return [-1, -1];

    let end = findLastPosition(nums, target);
    return [start, end];
};

/**
 * 寻找目标元素出现的第一个位置
 *  第一个出现的位置左边都是严格比它小的
 * 
 * @param {*} nums 
 * @param {*} target 
 * @returns 
 */
function findFirstPosition(nums, target) {
    let l = 0;
    let r = nums.length - 1;

    // 注意条件，严格小于的情况下进行二分查找，保证退出的时候r/l指针是重叠的
    while (l < r) {
        let mid = (l + r) >> 1;
        if (nums[mid] < target) {
            // 严格大于中间值，所以下一次搜索区域在右边 [mid+1, r]
            l = mid + 1;
        } else if (nums[mid] === target) {
            // 刚好等于，要向左边继续找，下一次搜索区域在左边 [l, mid]
            r = mid;
        } else {
            // 严格小于中间值，nums[mid] > target，搜索 [l, mid-1]
            r = mid - 1;
        }
    }

    return nums[l] === target ? l : -1;
}

/**
 * 寻找目标元素出现的最后位置
 *  最后出现的位置右边都是严格比它大的
 * 
 * @param {*} nums 
 * @param {*} target 
 */
function findLastPosition(nums, target) {
    let l = 0;
    let r = nums.length - 1;

    while (l < r) {
        // **** 这里需要 +1，向上取整
        // 原因是因为向右侧找的时候，如果不加1，假设只剩了两个元素，mid永远指向了左边元素
        // 因此就无法看右侧元素是否是满足条件的元素了，所以要让它选择右侧元素
        let mid = ((l + r) >> 1) + 1;

        if (nums[mid] < target) {
            // 严格大于中间值 nums[mid] < target，在右侧 [mid+1, r]
            l = mid + 1;
        } else if (nums[mid] === target) {
            // 刚好相等，要向右继续查找，搜索 [mid, r]
            l = mid;
        } else {
            // 严格小于中间值，下次搜索范围在左侧 [l, mid-1]
            r = mid - 1;
        }
    }
    // 因为已经在主函数中保证一定会存在元素，再进行结束位置搜索，所以直接返回
    return l;
}
```

```javascript
/**
 * 解法二：推荐这个
 * 
 *  是官网代码的答案，但是官网代码答案写的有点麻烦，这里是参照了精评里的答案，
 *  个人感觉更好理解
 * 
 *  代码复用，审题后发现可以只用一个辅助函数完成，找的两个位置分别是：
 *  1. 第一个大于等于target的位置
 *  2. 第一个大于等于target+1的位置，其实就是找第一个大于target的位置
 * 
 *  举例子，对于 [5,7,7,8,8,10], 8 的输入，找：
 *  1. 第一个 >=8 的位置，也就是 3，这个过程中设置指针为 mid，而不是 mid-1，保留住相等时的指针状态
 *  2. 第一个 >=9 的位置，这个数组中没有9，但是10>9，因此说是找 >=9，其实就是找 >8 的第一个位置
 * 
 *  返回结果时需要先判断是否找到了目标值
 *  1.没找到直接返回 [-1, -1]
 *  2.找到后也要判断一下，可能存在无大于目标值的情况，比如 [2,2],2 / [1],1 这类输入
 *      2.1 如果结束位置数字不大于目标值说明是上面这种情况，直接返回 [start, end]
 *      2.2 结束位大于目标值，返回前一位 [start, end-1]
 * 
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function (nums, target) {
    // 特判
    if (nums.length === 0) return [-1, -1];

    // 找第一个大于等于target的位置
    let start = findFirstPosition(nums, target);
    // 找第一个大于等于target+1的位置，其实就是找第一个大于target的位置
    let end = findFirstPosition(nums, target + 1);
    if (nums[start] === target) {
        // 找到目标值
        if ((nums[end] && nums[end] > target)) {
            // 结束位大于目标值，那么目标元素结束位置在 end-1 处
            return [start, end - 1];
        } else {
            // 结束位 <=，其实就是相等，那么不需要 -1
            return [start, end];
        }
    } else {
        return [-1, -1];
    }
};

/**
 * 二分查找第一个大于等于目标值的位置
 * @param {*} nums 
 * @param {*} target 
 * @returns 
 */
function findFirstPosition(nums, target) {
    let l = 0;
    let r = nums.length - 1;
    while (l < r) { //条件不能是 <=，因为下面边界的问题，如果是 <= 可能会退不出循环
        let mid = (l + r) >> 1;
        if (nums[mid] >= target) {
            r = mid; //这里没有 -1，因为可能存在相等的边界
        } else {
            l = mid + 1;
        }
    }
    return l;
}
```
<br/>



### [数组|回溯+剪枝] 39.组合总和
> <https://leetcode.cn/problems/combination-sum/>
>
> 这个帖子可以好好看看：
> [精选帖|回溯](https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/)
> 对回溯的一些总结也包含在里面

```
思路见注解，相关题：46.全排列
```

```javascript
/**
 * 回溯法 + 剪枝
 * 
 *  回溯，依次对target进行减的操作，直到刚好=0就是我们要找的路径
 * 
 *  1.一看是要找到所有解，第一想到回溯
 *  在不要求不记顺序的重复的基础上去用回溯写是很好写的，就是没有begin这个参数
 *  会产生 [2,2,3] [2,3,2] [3,2,2] 这样的解
 * 
 *  2.为了解决重复问题，需要修改回溯函数，思路是：
 *  修改下一次开始尝试的位置，不再尝试已经尝试过的路径
 *  因此多了一个begin参数，这个图解看下面这个链接吧
 *  https://leetcode.cn/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/
 *  
 *  3.剪枝：
 *  需要配合数组排序，如果目标值-当前值<0，后面的也是<0的
 *  也就无需继续，所以break
 * 
 *  ！这里是设计了一个begin参数，前面有 46 题是设计了used参数，两者结合看看，
 *  精选帖里也提到了这两个参数的设计
 * 
 * @param {number[]} candidates 无重复元素的整数数组
 * @param {number} target 目标值
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
    var res = [];
    // 排序，为了剪枝
    candidates.sort((a, b) => a - b);
    backtrack(candidates, target, 0, []);
    return res;

    /**
     * 
     * @param {*} nums 数组
     * @param {*} target 当前目标值
     * @param {*} begin 当前开始尝试的起始位置下标
     * @param {*} path 当前路径
     * @returns 
     */
    function backtrack(nums, target, begin, path) {
        // if (target < 0) return; //剪枝了，这个判断就不需要了
        if (target === 0) {
            res.push(Array.from(path));
            return;
        }

        for (let i = begin; i < nums.length; i++) {
            // 剪枝，已经<0了，后面的就不需要再试了，因为数组是按序排列的
            if (target - nums[i] < 0) break;
            path.push(nums[i]);
            backtrack(nums, target - nums[i], i, path);
            path.pop();
        }
    }
};
```
<br/>



### [数组] 42.接雨水 TODO
> <https://leetcode.cn/problems/trapping-rain-water/>

```
```

```javascript

```
<br/>



### [数组|全排列|回溯] 46.全排列 
> <https://leetcode.cn/problems/permutations/>

```
[思路 - 回溯]：
    1. 一看到要求所有全部解，每个步骤可以有多个选择的这种题
    首先想到的就是可以把解题思路用树画出来
    那么对树的深度优先遍历就是[回溯算法]

[注意点]
    1. 状态变量的维护
        - res 结果集
        - path 当前路径
        - used 标识已经被选择的节点
    2. JS数组是引用类型，所以在放路径的时候要放一个数组的浅拷贝值进去
    3. 注意回溯的步骤(***之后的两行)，相当于是退回上一步的选择

```

```javascript
/**
 * 回溯
 *  
 *  需要注意回溯的这一步
 * 
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
    // 特判
    let len = nums.length;
    if (len <= 1) return [nums];

    let res = [];
    backtrack([], nums, []);
    return res;

    /**
     * @param {*} path 
     * @param {*} nums 
     * @param {*} used 布尔数组，记录每个数字是否已经被当前路径选中，如果在路径中被使用了，就置为true
     * @returns 
     */
    function backtrack(path, nums, used) {
        if (len === path.length) {
            // 终止条件：已选路径层级与树的层级相同，退出
            res.push(Array.from(path));
            return;
        }

        // 遍历所有待选项
        for (let i = 0; i <= len - 1; i++) {
            if (used[i]) continue; //当前选项已经被选 跳过
            path.push(nums[i]);
            used[i] = true; //标识被选中的状态
            backtrack(path, nums, used);

            // *** 完成选择后进行回溯，就是状态重置
            path.pop();
            used[i] = false;
        }
    }
};
```
<br/>



### [二维数组] 48.旋转图像
> <https://leetcode.cn/problems/rotate-image/>

```
[解题思路] 参考官网解答
1.旋转：第[i]行的第[j]列的元素，经过旋转转到了：倒数第[i]列第[j]行的位置
    也就是 [i, j] => [j, n - i -1]
    但是简单粗暴的直接替换不行，原因看官网解释吧（方法二）
2.翻转代替旋转（官网方法三）
    先水平轴翻转；再主对角线翻转
    注意循环条件
```

```javascript
/**
 * [翻转]：先水平轴翻转；再主对角线翻转
 *  1.水平翻转时只翻转上半部分行就行，如果都翻转了就回到解放前了，中间行不用翻转，所以向下取整
 *  2.主对角线翻转时，只需要枚举对角线一侧即可
 * 
 *  时间复杂度 O(n^2)
 *  空间复杂度 O(1)
 * 
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
var rotate = function (matrix) {
    let n = matrix.length;

    // 1.水平翻转 [i][j] -> [n-i-1][j] 列不变，行变
    for (let i = 0; i < Math.floor(n / 2); i++) { //注意循环条件
        for (let j = 0; j < n; j++) {
            [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];
        }
    }
    // 2.主对角线翻转 [i][j] -> [j][i]
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) { //注意循环条件
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
        }
    }
};
```
<br/>



### [数组|动态规划] 53.最大字数组和（的值）
> <https://leetcode.cn/problems/maximum-subarray/>

```
1.动态规划法
    动态规划：将大问题的解转换为若干小问题的解；
    动态规划的要点是要找到 [状态初始值]、[子问题] 和 [状态转移方程]；
    附参考链接：
    https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/

2.解题思路：针对这道题，找动态规划的几个要点
    - [子问题]：以 nums[i] 结尾的连续子数组的最大和，重点在结尾、连续；
    - [状态初始值]：nums[0] 的值
    - [状态转移方程]：可以理解为是子问题之间的联系
        结合本题子问题，可以看到 dp[i] 的值与 dp[i-1] 有关
        如果 dp[i-1] 的值 >0，那么 dp[i]=dp[i-1]+nums[i]，不然就是 dp[i]=nums[i]
        这个很好理解，找最大解嘛，要在前面子问题基础上取非0整数才会是更大值

3.还写了暴力破解法哈哈哈哈，思路倒是没问题，不过超时了，没通过，也记录下来
```

```javascript
/**
 * 动态规划法
 * 
 * 时间复杂度 O(n)
 * 空间复杂度 O(n)
 * 
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    // dp[i] 表示以 nums[i] 结尾的连续子数组的最大和
    let dp = [];
    dp[0] = nums[0]; //动态规划初始值
    let max = dp[0]; //返回结果，初始化是第一个元素的值

    for (let i = 1; i < nums.length; i++) {
        // 状态转移方程
        if (dp[i - 1] <= 0) {
            dp[i] = nums[i];
        } else {
            dp[i] = dp[i - 1] + nums[i];
        }
        max = Math.max(dp[i], max);
    }

    return max;
};
```

```javascript
/**
 * 暴力破解：没通过哈哈哈哈，超时了
 * 
 * 时间复杂度 O(n^2)
 * 空间复杂度 O(1)
 * 
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
    let len = nums.length;
    if (len <= 1) return nums[0];

    let max = -Infinity; //一个无穷小的数，不加负号的话表示无穷大的数
    for (let i = 0; i < len; i++) {
        let sum = 0;
        for (let j = i; j < len; j++) {
            sum = sum + nums[j];
            max = Math.max(max, sum);
        }
    }
    return max;
};
```
<br/>



### [链表] 83.删除排序链表中的重复元素 
> <https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/>

```
```

```javascript
/**
 * 方法一：前后双指针，遍历一次比较两个指针的值是否一样：
 *  1. 一样的话丢弃同值节点（修改后指针的next），并继续前进前指针
 *  2. 不一样同时前进前后指针
 * 
 *  时间复杂度 O(n)
 *  空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
    let slow = head;
    let fast = head ? head.next : null;
    while (fast !== null) {
        if (fast.val === slow.val) {
            slow.next = fast.next;
            fast = fast.next;
        } else {
            slow = slow.next;
            fast = fast.next;
        }
    }
    return head;
};
```
```javascript
/**
 *
 * 方法二：单个指针就可以完成，思路与方法一一致 
 *  时间复杂度 O(n)
 *  空间复杂度 O(1)
 *
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
    if (!head) {
        return head;
    }
    let curr = head;
    while (curr.next !== null) {
        if (curr.val === curr.next.val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }
    return head;
};
```
<br/>



### [数组] 88.合并两个有序数组
> <https://leetcode.cn/problems/merge-sorted-array/>

```
从下到上说一下各个方法的优缺点:

[方法三]: 
    简单粗暴方法就是 [直接合并数组并再次排序]，
    当然不是最优解，而且也没有利用题目说的两个都是有序的，也没有利用到 nums1.length = m+n 的优势
[方法二]: 
    [双指针] 法利用了已经排序的优势，
    但是需要一个新的数组作为中间数组，
    而且最后因为题目要修改nums1，所以又需要再次把最后得到的数组再赋值到 nums1 里
[方法一]: 
    [逆向双指针] 是最优解了，因为既利用了已排序的优势，又是直接修改了 nums1，不需要额外空间

```

```javascript
/**
 * 
 * 方法一：逆向双指针
 * 
 * [思路]：
    这道题仔细审题会发现需要做的是直接修改 nums1 数组；
    其中的一个 [要点] 在于从后面开始修改数组，因为后面都是0补齐的；
    所以这道题有三个指针，分别初始化指向完整数组也就是 nums1 的尾部、nums1 有效数组尾部、nums2 有效数组尾部；
        这里操作指针：直接在操作完跟在后面减一，也就是先操作后--，无需单独写了
    还需要注意的一个点在于对于后两个指针的判断，因为有可能存在无有效数组的情况；
 * 
 * 
 * 时间复杂度 O(m+n) 因为指针至多移动 m+n 次
 * 空间复杂度 O(1) 因为是直接对 nums1 修改的
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    let k = m + n - 1;
    m--;
    n--;

    while (m >= 0 || n >= 0) {
        if (m === -1) {
            // 第一个数组无有效数字
            nums1[k--] = nums2[n--];
        } else if (n === -1) {
            // 第二个数组无有效数字
            nums1[k--] = nums1[m--];
        } else if (nums1[m] > nums2[n]) {
            // 前者数字更大，从后覆盖数组
            nums1[k--] = nums1[m--];
        } else {
            // 后者数字更大/两者相等都走这里逻辑
            nums1[k--] = nums1[n--];
        }
    }
};
```

```javascript
/**
 * 
 * 方法二：双指针
 * 
 * 
 *  时间复杂度 O(m+n) 指针移动至多 m+n 次
 *  空间复杂度 O(m+n) 需要长度为 m+n 长度的数组
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    // 初始化两个数组的指针，从头开始
    let p1 = 0, p2 = 0;
    let k = 0;
    // 一个中间数组
    let sorted = new Array(m + n).fill(0);

    // 双指针正向排序，依次取更小值放入
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            // 第一个数组已经遍历完了，直接放第二个数组的元素
            sorted[k++] = nums2[p2++];
        } else if (p2 === n) {
            // 第二个数组已经历完了，直接放第一个数组的元素
            sorted[k++] = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            // 都未遍历完，前者小
            sorted[k++] = nums1[p1++];
        } else {
            // 后者小/相等
            sorted[k++] = nums2[p2++];
        }
    }

    // 把中间数组倒到 nums1 里
    for (let i = 0; i < sorted.length; i++) {
        nums1[i] = sorted[i];
    }
};
```

```javascript
/**
 * 
 * 方法三：简答粗暴 直接合并后排序
 * 
 *  1. splice(start, deleteCount [, item1 [, item2 [, ...]]])
 *      - 从下标 start 开始，删除 deleteCount 个数的元素；如果后面还有元素会添加进数组中
 * 
 *  时间复杂度 O((m+n)log(m+n)) 空间复杂度 O(log(m+n)) 直接套用快速排序的复杂度即可
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    // 从 m 下标开始删除 n 个元素，并添加 nums2 的各个元素
    nums1.splice(m, n, ...nums2);
    // 从小到大排序
    nums1.sort((a, b) => a - b);
};
```
<br/>



### [树] 94.二叉树的中序遍历
> <https://leetcode.cn/problems/binary-tree-inorder-traversal/>

```
[树]
    1. 树结构
        根节点无父节点，除了叶子节点之外所有节点都有一个或多个节点
        父节点与子节点之间用指针连接，因此操作树需要操作大量指针

        面试过程中遇到的树一般都是 [二叉树]：
            它是一种特殊结构的树，二叉树每个节点最多有两个子节点

        [二叉树] 又有很多特例，[二叉搜索树] 是其中之一，二叉搜索树中：
            左子结点总是小于等于根节点
            右子节点总是大于等于根节点

    2. 树的遍历方式（深度遍历）
        - 前序遍历：根节点->左子结点->右子节点
        - 中序遍历：左子结点->根节点->右子节点
        - 后序遍历：左子结点->右子节点->根节点

        记得话其实所谓的前中后是指根节点在哪个位置遍历
        遍历树的三种方式都有递归和循环两种实现方式，但是递归实现更简洁

    3. 深度优先遍历 DFS 隐式的利用了[栈]数据结构
       广度优先遍历 BFS 利用[队列]数据结构

[思路]
    这道题，中序遍历，深度遍历，使用递归|迭代完成
```

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * 方法一：递归
 * 
 *  树的遍历天生就符合递归特性
 *  核心是放入根节点的时机：
 *      递归左子树->放入根节点->递归右子树（中序）
 *      放入根节点->递归左子树->递归右子树（前序）
 *      递归左子树->递归右子树->放入根节点（后序）
 *  
 * 
 *  时间复杂度 O(n) n为二叉树节点的个数
 *  空间复杂度 O(n)
 * 
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    let res = [];
    inorder(root);
    return res;

    // 递归函数
    function inorder(root) {
        if (!root) return;
        inorder(root.left); //递归遍历左子结点
        res.push(root.val); //加入根节点
        inorder(root.right); //递归遍历右子节点
    }
};
```
> [迭代法遍历树](https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/die-dai-fa-by-jason-2/)
```javascript
/**
 * 方法二：迭代
 * 
 *  迭代利用栈结构完成，中序遍历，也就是 左中右
 * 
 *  时间复杂度 O(n) n为二叉树节点的个数
 *  空间复杂度 O(n)
 * 
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    const res = []; //结果
    const stk = []; //栈

    // 遍历到根节点 root=null，这时候如果栈内还有说明树没有遍历完
    while (root || stk.length) {
        // 深度遍历
        while (root) {
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        res.push(root.val);
        root = root.right; //取右子节点，继续深度遍历
    }
    return res;
};
```
<br/>



### [树] 102.二叉树的层序遍历
> <https://leetcode.cn/problems/binary-tree-level-order-traversal/>

```
1. 层序遍历就是：广度优先遍历 BFS
    利用队列数据结构完成遍历，区分每一层的节点，附参考链接：
    https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/
    这个链接思路讲的就很清楚，尤其是其中如何区分是每层的节点这块

2. JS队列，先说一下相关的API
    - Array.prototype.unshift()：添加一个/多个元素到数组的 [开头]，并返回该数组的 [新长度]
    - Array.prototype.shift()：删除 [第一个] 元素并返回 [该元素的值]
    - Array.prototype.push()：添加一个/多个元素到数组的 [末尾]，并返回该数组的 [新长度]
    - Array.prototype.pop()：删除 [最后一个] 元素并返回 [该元素的值]

3. JS队列实现思路，根据上面的API模拟队列：
    - 入队push() & 出队shift()
```

```javascript
/**
 * 广度优先遍历
 * 
 *  时间复杂度 O(n) 每个节点进出队列一次
 *  空间复杂度 O(n) 队列元素至多不超过n
 * 
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
    if (!root) return []; //特判

    let res = []; //结果数组
    let queue = []; //节点队列
    queue.push(root);

    while (queue.length > 0) {
        let level = []; //当前层节点数组
        let len = queue.length; //统计当前层的节点个数

        // 对当前层的每一个节点，出队列，然后将其左右子节点加入队列
        for (let i = 0; i < len; i++) { //i没有意义，只是为了遍历完当前层节点个数
            let node = queue.shift(); //出队
            level.push(node.val);

            // 该节点ndoe的左右节点，即下层节点入队
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        res.push(level); //把当前层放入结果数组
    }

    return res;
};
```
<br/>



### [树] 104.二叉树的最大深度
> <https://leetcode.cn/problems/maximum-depth-of-binary-tree/>

```javascript
/**
 * 递归、深度优先遍历
 * 
 * 时间复杂度 O(n)
 * 空间复杂度 O(height) 递归函数需要栈空间，栈空间大小取决于高度
 * 
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    if (!root) {
        return 0;
    } else {
        let left = maxDepth(root.left);
        let right = maxDepth(root.right);
        // 这个是在递归回退的时候计算深度值，前面这两行只是不断向下找最深的叶子结点
        // 当递归到最后一层即找到最深的叶子结点时会返回 left/right=0，回退时会在兄弟节点子树深度与自身深度取max后+1计算出当前深度
        // 这样一层一层回退回去得到树的最大深度
        return 1 + Math.max(left, right);
    }
};
```
<br/>



### [链表] 141.环形链表
> <https://leetcode.cn/problems/linked-list-cycle/>

```javascript
/**
 * 双指针：快慢指针法
 * 
 *  快指针每次走2步，慢指针每次走1步，如果两个指针相遇代表有环
 *  如果快指针走到头了（null）也没相遇那就是没环
 * 
 *  时间复杂度 O(n)
 *  空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
    let fast = head;
    let slow = head;
    while (fast !== null && fast.next !== null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) {
            return true;
        }
    }
    return false;
};
```

```javascript
/**
 * 哈希表
 *  当元素两次进入哈希表代表有环
 * 
 *  时间复杂度 O(n)
 *  空间复杂度 O(n) 
 * 
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function (head) {
    if (head === null || head.next === null) return false;

    let set = new Set();
    while (head) {
        if (set.has(head)) {
            return true;
        }
        set.add(head);
        head = head.next;
    }
    return false;
};
```
<br/>



### [链表] 206.反转链表
> <https://leetcode.cn/problems/reverse-linked-list/>

```
方法还是蛮多的：
1.我第一反应是利用[栈]的特性完成
2.链表的题用指针是不会出现的，前后指针完成迭代反转
3.递归的我没写，日后有机会重刷再补充吧
```

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * 方法一：栈
 * 
 *  第一反应就是利用栈的特性完成反转
 *  唯一需要注意的就是出栈后最后一个节点即原来的头结点.next->null
 * 
 *  时间复杂度 O(n)
 *  空间复杂度 O(n) 栈的消耗
 * 
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
    let stack = [];
    while (head) {
        stack.push(head);
        head = head.next;
    }
    let dummy = new ListNode(); //哑节点，用来形成新的链表
    let cur = dummy;
    while (stack.length > 0) {
        cur.next = stack.pop();
        cur = cur.next;
    }
    // 这里需要注意，把栈内最后一个元素，即原来的头结点.next->null，不然会形成环
    cur.next = null;
    return dummy.next;
};
```

```javascript
/**
 * 方法二：双指针-前后指针 | 迭代
 * 
 *  前后指针进行遍历，前指针.next->后指针完成反转
 *  然后前后指针前移，直到遍历完链表
 * 
 *  时间复杂度 O(n)
 *  空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
    let cur = null;
    let prev = head;
    while (prev) {
        let temp = prev.next;
        prev.next = cur;
        cur = prev;
        prev = temp;
    }
    return cur;
};
```
<br/>



### [链表] 237.删除链表中的节点
> <https://leetcode.cn/problems/delete-node-in-a-linked-list/description/>

```
核心：既然干不掉自己就干掉下一个节点
```

```javascript
/**
 * 时间复杂度 O(1)
 * 空间复杂度 O(1)
 * 
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function (node) {
    node.val = node.next.val;
    node.next = node.next.next;
};
```
<br/>



### [数组] 322.零钱兑换 TODO
> <https://leetcode.cn/problems/coin-change/>

```
```

```javascript

```
<br/>



### [数组|队列] 933.最近的请求次数
> <https://leetcode.cn/problems/number-of-recent-calls/>

```
这道题乍一看看不懂，其实简单的一批：实现一个类和其中的一个ping方法
核心是这个ping方法，这个方法需要做两件事：
1）维护一个请求队列，每一次调用都会新增一个请求，值是时间t
2）输出当前队列中范围在 [t-3000, t] 的请求的个数

说白了就是维护一个队列，并输出符合范围的队列个数
```

```javascript
/** 
 * 时间复杂度O(n) 
 * 空间复杂度O(n) 
 * */
var RecentCounter = function () {
    this.rs = [];
};

/**
 * ping方法：
 *  新增一个请求，并返回 [t-3000, t] 范围内的请求数
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
    this.rs.push(t); // 向队列中新增一个请求
    while (this.rs[0] < (t - 3000)) {
        this.rs.shift(); // 不符合要求的出列
    }
    return this.rs.length;
};
```
<br/>