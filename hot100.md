- [[数组] 1.两数之和](#数组-1两数之和)
- [[链表] 2.两数相加](#链表-2两数相加)
- [[字符串] 3.无重复字符的最长子串(的长度)](#字符串-3无重复字符的最长子串的长度)

<br/>

### [数组] 1.两数之和 
```
https://leetcode.cn/problems/two-sum/
```

```
1. 推荐方法一：利用 [哈希表] 减少再次遍历匹配
2. 拓展之ES6 Map的使用，特殊在于key可以是对象
    - size 属性
    - get(key)
        - 返回对应的值
    - set(key, value)
        - 注意：重复key会覆盖
        - 返回当前 Map 对象，因此可以链式调用
    - has(key): boolean
    - delete(key): boolean
    - clear(): void 清空
```

```TypeScript
/**
 * 方法一: 哈希表 [推荐，更优解] 只遍历一次
 * 
 * 时间复杂度 O(n)，空间复杂度 O(n) 哈希表开销
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 1. 初始化一个map<key, value>，key是数值，value是下标
    let map = new Map();

    /**
     * 2. 遍历每一个值：先找是否已有符合条件的另一个值在map中，有则直接返回，无则放入继续遍历
     */
    for (let i = 0; i < nums.length; i++) {
        // 找差值，也就是另一个数
        let otherValue = target - nums[i];
        if (map.has(otherValue)) {
            return [map.get(otherValue), i];
        } else {
            // 未找到符合条件的，先放入元素，继续遍历
            map.set(nums[i], i);
        }
    }
    // 未找到，返回空数组
    return [];
};


/**
 * 方法二: 暴力枚举
 * 
 * 时间复杂度 O(n2)，空间复杂度 O(1)
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 双层遍历，直接看 num1 + num2 是否等于 target
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            // 里层遍历不需要从头遍历了
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
};
```
<br/>



### [链表] 2.两数相加 
```
https://leetcode.cn/problems/add-two-numbers/
```

```
1. 注意链表新增节点的方式，遍历链表一般都是用while配合指针的移动，最后方法返回的是链表头结点
2. 两数相加一些老写的东西：
    - sum % 10，取模，计算出来的是个位数值，比如 (7+8) % 10 = 5
    - Math.floor(sum/10) 是计算进制位，Math.floor(15/10) = 1
```

```javascript
/**
 * 仔细观察就能看到，因为链表是逆序，所以直接链表从头结点开始进行相加进位即可
 * 需要注意的一个小点是对最后一位的处理
 * 
 * 时间复杂度 O(max(m,n))：m/n 分别为两个链表的长度，因为遍历链表的每个位置需要 O(1) 的时间
 * 空间复杂度 O(1) 返回值不计入空间复杂度
 * 
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    // 初始化结果链表的头结点、尾/当前节点
    let head = null, current = null;
    // 进制位
    let k = 0;

    // 遍历完两个链表无论谁长谁短
    while (l1 || l2) {
        let val1 = l1 ? l1.val || 0 : 0;
        let val2 = l2 ? l2.val || 0 : 0;

        // 算和
        let sum = val1 + val2 + k;

        // 计算进制，下一次计算时使用
        // k = (sum > 10) ? 1 : 0;
        k = Math.floor(sum / 10);

        // 取模，得到该节点的值；比如 7+8，value=5
        let value = sum % 10;
        // 新链表，无头结点
        if (!head) {
            head = current = new ListNode(value);
        } else {
            // 新增链表节点，移动指针
            current.next = new ListNode(value);
            current = current.next;
        }

        // 移动链表指针
        l1 = l1 && l1.next;
        l2 = l2 && l2.next;
    }

    // 链表结束遍历后处理可能的最后一位
    if (k > 0) {
        current.next = new ListNode(k);
    }

    // 返回链表头结点
    return head;
};

```
<br/>



### [字符串] 3.无重复字符的最长子串(的长度)
```
https://leetcode.cn/problems/longest-substring-without-repeating-characters/
```

```
1. 滑动窗口的应用，不仅限于这道题
2. 拓展补充 ES6 Set
    - size属性
    - add(value)
    - delete(value): boolean
    - has(value): boolean
    - clear()
3. 字符串获取某个位置上的字符：str.charAt(index)
```

```javascript
/**
 * 滑动窗口：
 *  遍历每一个元素为其找到最大长度窗口（使用两个指针移动窗口），在每一次遍历后更新最大长度
 * 
 *  时间复杂度 O(n)
 * 
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    // 滑动窗口的右指针，左指针就是遍历字符串的指针
    let right = 0;
    // 最长长度，在针对每一个元素的窗口滑动之后都会去重新取新的最大值
    let max = 0;
    // 辅助判断是否有相同字符出现
    let set = new Set();

    // 依次遍历，找每一个元素的最大滑动窗口
    for (let left = 0; left < s.length; left++) {
        // 只要右指针未越界，元素未重复，就移动右指针并添加元素
        while (right < s.length && !set.has(s.charAt(right))) {
            set.add(s.charAt(right));
            right++;
        }
        // 重新计算最大长度
        max = Math.max(max, right - left);
        // 遍历结束，移除最左侧字符
        set.delete(s.charAt(left));
    }

    return max;
};

```
<br/>