- [[数组] 1.两数之和](#数组-1两数之和)
- [[链表] 2.两数相加](#链表-2两数相加)
- [[字符串] 3.无重复字符的最长子串（的长度）](#字符串-3无重复字符的最长子串的长度)
- [[数组] 4.寻找两个正序数组的中位数（TODO）](#数组-4寻找两个正序数组的中位数todo)
- [[数组] 88.合并两个有序数组](#数组-88合并两个有序数组)
- [[字符串] 5.最长回文子串](#字符串-5最长回文子串)
- [[数组] 11.盛最多水的容器](#数组-11盛最多水的容器)
- [[数组] 15.三数之和](#数组-15三数之和)
- [[字符串|回溯] 17.电话号码的字母组合](#字符串回溯-17电话号码的字母组合)
- [[链表] 19.删除链表的倒数第N个节点](#链表-19删除链表的倒数第n个节点)
- [[数组|栈] 20.有效的括号](#数组栈-20有效的括号)
- [[链表] 21.合并两个有序链表](#链表-21合并两个有序链表)
- [[回溯] 22.括号生成](#回溯-22括号生成)
- [[链表数组] 24.合并K个升序链表](#链表数组-24合并k个升序链表)
- [[数组] 31.下一个排列](#数组-31下一个排列)
- [[] 32.最长有效括号](#-32最长有效括号)
- [[数组] 33.搜索旋转排序数组](#数组-33搜索旋转排序数组)
- [[数组] 34.在排序数组中查找元素的第一个和最后一个位置](#数组-34在排序数组中查找元素的第一个和最后一个位置)
- [[数组] 39.组合总和](#数组-39组合总和)
- [[数组] 42.接雨水](#数组-42接雨水)
<br/>

### [数组] 1.两数之和 
```
https://leetcode.cn/problems/two-sum/
```

```
1. 推荐方法一：利用 [哈希表] 减少再次遍历匹配
2. 拓展之ES6 Map的使用，特殊在于key可以是对象
    - size 属性
    - get(key)
        - 返回对应的值
    - set(key, value)
        - 注意：重复key会覆盖
        - 返回当前 Map 对象，因此可以链式调用
    - has(key): boolean
    - delete(key): boolean
    - clear(): void 清空
```

```TypeScript
/**
 * 方法一: 哈希表 [推荐，更优解] 只遍历一次
 * 
 * 时间复杂度 O(n)，空间复杂度 O(n) 哈希表开销
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 1. 初始化一个map<key, value>，key是数值，value是下标
    let map = new Map();

    /**
     * 2. 遍历每一个值：先找是否已有符合条件的另一个值在map中，有则直接返回，无则放入继续遍历
     */
    for (let i = 0; i < nums.length; i++) {
        // 找差值，也就是另一个数
        let otherValue = target - nums[i];
        if (map.has(otherValue)) {
            return [map.get(otherValue), i];
        } else {
            // 未找到符合条件的，先放入元素，继续遍历
            map.set(nums[i], i);
        }
    }
    // 未找到，返回空数组
    return [];
};
```
```TypeScript
/**
 * 方法二: 暴力枚举
 * 
 * 时间复杂度 O(n^2)，空间复杂度 O(1)
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 双层遍历，直接看 num1 + num2 是否等于 target
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            // 里层遍历不需要从头遍历了
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
};
```
<br/>



### [链表] 2.两数相加 
```
https://leetcode.cn/problems/add-two-numbers/
```

```
1. 注意链表新增节点的方式，遍历链表一般都是用while配合指针的移动，最后方法返回的是链表头结点
2. 两数相加一些老写的东西：
    - sum % 10，取模，计算出来的是个位数值，比如 (7+8) % 10 = 5
    - Math.floor(sum/10) 是计算进制位，Math.floor(15/10) = 1
```

```javascript
/**
 * 仔细观察就能看到，因为链表是逆序，所以直接链表从头结点开始进行相加进位即可
 * 需要注意的一个小点是对最后一位的处理
 * 
 * 时间复杂度 O(max(m,n))：m/n 分别为两个链表的长度，因为遍历链表的每个位置需要 O(1) 的时间
 * 空间复杂度 O(1) 返回值不计入空间复杂度
 * 
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    // 初始化结果链表的头结点、尾/当前节点
    let head = null, current = null;
    // 进制位
    let k = 0;

    // 遍历完两个链表无论谁长谁短
    while (l1 || l2) {
        let val1 = l1 ? l1.val || 0 : 0;
        let val2 = l2 ? l2.val || 0 : 0;

        // 算和
        let sum = val1 + val2 + k;

        // 计算进制，下一次计算时使用
        // k = (sum > 10) ? 1 : 0;
        k = Math.floor(sum / 10);

        // 取模，得到该节点的值；比如 7+8，value=5
        let value = sum % 10;
        // 新链表，无头结点
        if (!head) {
            head = current = new ListNode(value);
        } else {
            // 新增链表节点，移动指针
            current.next = new ListNode(value);
            current = current.next;
        }

        // 移动链表指针
        l1 = l1 && l1.next;
        l2 = l2 && l2.next;
    }

    // 链表结束遍历后处理可能的最后一位
    if (k > 0) {
        current.next = new ListNode(k);
    }

    // 返回链表头结点
    return head;
};

```
<br/>



### [字符串] 3.无重复字符的最长子串（的长度）
```
https://leetcode.cn/problems/longest-substring-without-repeating-characters/
```

```
1. 滑动窗口的应用，不仅限于这道题
2. 拓展补充 ES6 Set
    - size属性
    - add(value)
    - delete(value): boolean
    - has(value): boolean
    - clear()
3. 字符串获取某个位置上的字符：str.charAt(index)
```

```javascript
/**
 * 滑动窗口
 *  遍历每一个元素为其找到最大长度窗口（使用两个指针移动窗口），在每一次遍历后更新最大长度
 * 
 *  时间复杂度 O(n)
 * 
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    // 滑动窗口的右指针，左指针就是遍历字符串的指针
    let right = 0;
    // 最长长度，在针对每一个元素的窗口滑动之后都会去重新取新的最大值
    let max = 0;
    // 辅助判断是否有相同字符出现
    let set = new Set();

    // 依次遍历，找每一个元素的最大滑动窗口
    for (let left = 0; left < s.length; left++) {
        // 只要右指针未越界，元素未重复，就移动右指针并添加元素
        while (right < s.length && !set.has(s.charAt(right))) {
            set.add(s.charAt(right));
            right++;
        }
        // 重新计算最大长度
        max = Math.max(max, right - left);
        // 遍历结束，移除最左侧字符
        set.delete(s.charAt(left));
    }

    return max;
};
```
<br/>



### [数组] 4.寻找两个正序数组的中位数（TODO）
```
https://leetcode.cn/problems/median-of-two-sorted-arrays/
```

```

```

```javascript

```
<br/>



### [数组] 88.合并两个有序数组
```
https://leetcode.cn/problems/merge-sorted-array/
```

```
从下到上说一下各个方法的优缺点:

[方法三]: 
    简单粗暴方法就是 [直接合并数组并再次排序]，
    当然不是最优解，而且也没有利用题目说的两个都是有序的，也没有利用到 nums1.length = m+n 的优势
[方法二]: 
    [双指针] 法利用了已经排序的优势，
    但是需要一个新的数组作为中间数组，
    而且最后因为题目要修改nums1，所以又需要再次把最后得到的数组再赋值到 nums1 里
[方法一]: 
    [逆向双指针] 是最优解了，因为既利用了已排序的优势，又是直接修改了 nums1，不需要额外空间

```

```javascript
/**
 * 
 * 方法一：逆向双指针
 * 
 * [思路]：
    这道题仔细审题会发现需要做的是直接修改 nums1 数组；
    其中的一个 [要点] 在于从后面开始修改数组，因为后面都是0补齐的；
    所以这道题有三个指针，分别初始化指向完整数组也就是 nums1 的尾部、nums1 有效数组尾部、nums2 有效数组尾部；
        这里操作指针：直接在操作完跟在后面减一，也就是先操作后--，无需单独写了
    还需要注意的一个点在于对于后两个指针的判断，因为有可能存在无有效数组的情况；
 * 
 * 
 * 时间复杂度 O(m+n) 因为指针至多移动 m+n 次
 * 空间复杂度 O(1) 因为是直接对 nums1 修改的
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    let k = m + n - 1;
    m--;
    n--;

    while (m >= 0 || n >= 0) {
        if (m === -1) {
            // 第一个数组无有效数字
            nums1[k--] = nums2[n--];
        } else if (n === -1) {
            // 第二个数组无有效数字
            nums1[k--] = nums1[m--];
        } else if (nums1[m] > nums2[n]) {
            // 前者数字更大，从后覆盖数组
            nums1[k--] = nums1[m--];
        } else {
            // 后者数字更大/两者相等都走这里逻辑
            nums1[k--] = nums1[n--];
        }
    }
};
```

```javascript
/**
 * 
 * 方法二：双指针
 * 
 * 
 *  时间复杂度 O(m+n) 指针移动至多 m+n 次
 *  空间复杂度 O(m+n) 需要长度为 m+n 长度的数组
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    // 初始化两个数组的指针，从头开始
    let p1 = 0, p2 = 0;
    let k = 0;
    // 一个中间数组
    let sorted = new Array(m + n).fill(0);

    // 双指针正向排序，依次取更小值放入
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            // 第一个数组已经遍历完了，直接放第二个数组的元素
            sorted[k++] = nums2[p2++];
        } else if (p2 === n) {
            // 第二个数组已经历完了，直接放第一个数组的元素
            sorted[k++] = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            // 都未遍历完，前者小
            sorted[k++] = nums1[p1++];
        } else {
            // 后者小/相等
            sorted[k++] = nums2[p2++];
        }
    }

    // 把中间数组倒到 nums1 里
    for (let i = 0; i < sorted.length; i++) {
        nums1[i] = sorted[i];
    }
};
```

```javascript
/**
 * 
 * 方法三：简答粗暴 直接合并后排序
 * 
 *  1. splice(start, deleteCount [, item1 [, item2 [, ...]]])
 *      - 从下标 start 开始，删除 deleteCount 个数的元素；如果后面还有元素会添加进数组中
 * 
 *  时间复杂度 O((m+n)log(m+n)) 空间复杂度 O(log(m+n)) 直接套用快速排序的复杂度即可
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    // 从 m 下标开始删除 n 个元素，并添加 nums2 的各个元素
    nums1.splice(m, n, ...nums2);
    // 从小到大排序
    nums1.sort((a, b) => a - b);
};
```
<br/>



### [字符串] 5.最长回文子串
```
https://leetcode.cn/problems/longest-palindromic-substring/
```

```
1.首先先搞清楚 [回文子串] 是啥再答题：
    - 回文串是从左到右读和从右到左读都一样的字符串，有轴对称的特点
    - 子串：是指原始字符串的一个 [连续] 子集
        - 子序列：原始字符串的一个子集
2.这里只写了中心扩散法，还有其他方法：
    - 动态规划法（这个还挺常规解法的，但是我看不懂，之后再补吧）
    - Manacher算法（这个有难度）
```

```javascript
/**
 * 中心扩散法：
 *  [思想]:
 *      1. 遍历字符串的每一个字符，并将其作为子串的中点字符即中心，
 *      2. 以当前字符为中心向两边扩散：查找偶数回文子串和奇数回文子串
 *          2.1 偶数子串的中心位是2个数
 *          2.2 奇数子串的中心位是1个数
 *      3. 比较更新最大长度，记录中心位置下标
 *      4. 完成遍历后截取字符串（这个操作在确定了最长子串中心位后再整个方法最后执行就行，因为比较耗时）
 * 
 *  [注意]：中间那个分别求奇/偶回文子串其实也可以写成两个 while 分别算一下，然后比较最长长度再更新起始位置
 *          这样写的优势在于不用在计算起始位置时找规律
 * 
 * 
 *  时间复杂度 O(n^2) 空间复杂度 O(1)
 * 
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
    // 0.特殊判断
    let len = s.length;
    if (len < 2) return s;

    // 1. 初始化最长长度和子串开始位置下标
    let maxLen = 0;
    let begin = 0;

    // 2. 只需要判断到倒数第二个为止的元素即可
    for (let i = 0; i < len - 1; i++) {
        // 3.1 奇数回文串最长长度
        let [oddLen, oddLeft] = expandAroundCenter(s, i, i);
        // 3.2 偶数回文串最长长度
        let [evenLen, evenLeft] = expandAroundCenter(s, i, i + 1);

        // 4. 更新最长长度和子串起始下标
        let curMaxLen = Math.max(oddLen, evenLen);
        if (curMaxLen > maxLen) {
            maxLen = curMaxLen;
            begin = oddLen > evenLen ? oddLeft : evenLeft;
            // // 这里奇数偶数都可以用这个算式计算出起始位置， / 用来向下取整；
            // 不过我始终没明白怎么算出来的，所以我在辅助函数里直接返回回来
            // begin = i - (maxLen - 1) / 2;
        }
    }

    // 5. 截取字符串返回
    return s.slice(begin, begin + maxLen);
};

/**
 * 
 * 辅助函数：
 *  1.以传入的中心位下标，开始两边扩散找回文串，有两种情况：
 *    不过无论是哪种，第一步都可以直接进行左右比较，然后开始左右拓展
 *      1.1 -> left=right，中心位是同一个下标的元素，所以要找的是奇数回文串
 *      1.2 -> right=left+1，中心位是两个，找的是偶数回文串
 *  2.左右匹配相同就移动指针，一直到不相同了就退出 while 循环 (break 也可以退出 while 循环)
 *  3.返回子串长度和子串开始位置
 * 
 * @param s 字符串
 * @param left 左中心位下标
 * @param right 右中心位下标
 * @returns [length, begin]
 */
function expandAroundCenter(s, left, right) {
    while (left >= 0 && right < s.length && s.charAt(left) === s.charAt(right)) {
        left--;
        right++;
    }
    return [right - left - 1, left + 1];
}
```
<br/>



### [数组] 11.盛最多水的容器
```
https://leetcode.cn/problems/container-with-most-water/
```

```
- 理解题目：计算的盛水最多容器其实就是计算矩形面积的最大值，计算公式就是距离*min(h1,h2)
- 解题要点：双指针
- 解法：
    1.[双指针] 此题最优解：
        因为要计算的是矩形面积，
        而面积更大的条件无非是在控制一边的情况下，另一边越大越有可能成为更大的容器。
        所以基于这个想法移动短的边，寻找可能的更大面积，同样也是保留计算过程中的最大面积。
    2.[暴力解法] 没什么好说，依次计算所有面积，保留最大面积（这个提交没通过，超时了）
```

```javascript
/**
 * [双指针法] 此题最优解：
    因为要计算的是矩形面积，
    而面积更大的条件无非是在控制一边的情况下，另一边越大越有可能成为更大的容器。
    所以基于这个想法移动短的边，寻找可能的更大面积，同样也是保留计算过程中的最大面积。
 *  
 * 时间复杂度 O(n) 空间复杂度 O(1)
 * 
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let maxArea = 0;
    let len = height.length;
    let j = len - 1; //初始化右侧指针

    for (let i = 0; i < len - 1; i++) {
        // 两个指针相遇作为结束条件
        while (i < j) {
            maxArea = Math.max(
                maxArea,
                (j - i) * Math.min(height[i], height[j])
            );
            // 比较两边值的大小，移动更小的那一边，寻求更大面积解
            (height[i] > height[j]) ? j-- : i++;
        }
    }
    return maxArea;
};
```

```javascript
/**
 * 暴力解法：
 *  两次循环依次计算盛水面积，保留最大值
 * 
 * 时间复杂度 O(n^2) 空间复杂度 O(1)
 * 
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let len = height.length;
    let maxArea = 0;
    for (let i = 0; i < len - 1; i++) {
        for (let j = i + 1; j < len; j++) {
            maxArea = Math.max(maxArea, (j - i) * Math.min(height[i], height[j]));
        }
    }
    return maxArea;
};
```
<br/>



### [数组] 15.三数之和
```
https://leetcode.cn/problems/3sum/
```

```javascript
/**
 * 排序+双指针：
 * 
 *  先进行排序，然后开始遍历，相当于是固定第一个元素，然后找两数之和，所以用了双指针缩小范围
 *  需要注意的就是去重的操作：
 *   1.第一个是在遍历时如果遇到与上一个遍历相同的元素，就直接跳过当次循环
 *   2.第二个是在为某一个元素找到一组解之后，继续制动指针找其余解，加了一层判断，确保移动到不同值上
 * 
 *  时间复杂度 O(n^2)：排序复杂度是 O(N logN)，但是循环是 O(n^2)，因此总的时间复杂度 O(n^2)
 * 
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
    let result = [];
    // 从小到大排序
    nums.sort((a, b) => a - b);
    // 依次遍历
    for (let i = 0; i < nums.length - 2; i++) {
        // 因为按序排列，当最小数已经大于0时就可以直接退出循环了
        if (nums[i] > 0) break;
        // 比对是否与上一个数值相同，达到去重目的
        if (i > 0 && nums[i] === nums[i - 1]) continue;
        // 初始化双指针
        let left = i + 1;
        let right = nums.length - 1;
        while (left < right) {
            if (nums[i] + nums[left] + nums[right] === 0) {
                // 找到了其中一组解
                result.push([nums[i], nums[left], nums[right]]);
                // 移动指针
                left++;
                right--;
                // 判断移动后指针所指元素是否与上一个元素相同，相同则继续移动，避免重复元素
                while (left < right && nums[left] === nums[left - 1]) left++;
                while (left < right && nums[right] === nums[right + 1]) right--;
            } else {
                // 与0做比较决定移动哪一个指针
                (nums[left] + nums[right] + nums[i]) > 0 ? right-- : left++
            }
        }
    }
    return result;
};
```
<br/>



### [字符串|回溯] 17.电话号码的字母组合
```
https://leetcode.cn/problems/letter-combinations-of-a-phone-number/
```

```
1.使用回溯法：
    在图上画一下这个题的思路之后会发现很像树，
    所以我们沿着其中一个节点一直遍历找到它对应的字符串，直到没有节点了
    就可以把这个路径字符串添加到结果集当中了

    这个过程中每一个都是在当前路径字符串上添加结果，
    直到全部遍历结束了才添加到结果集中
```

```javascript
/**
 * 回溯法：
 *  有点像树，沿着一条路径深度遍历直到没有数字了
 * 
 *  时间复杂度 O(3^m * 4^n)：
 *  1. 其中m是输入中对应3个字母的数字个数（包括数字 2、3、4、5、6、8）
 *  2. n是输入中对应4个字母的数字个数（包括数字 7、9）
 * 
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function (digits) {
    if (digits.length === 0) return [];

    // 用哈希表存储按键对应的字母
    let map = new Map([
        ['2', 'abc'],
        ['3', 'def'],
        ['4', 'ghi'],
        ['5', 'jkl'],
        ['6', 'mno'],
        ['7', 'pqrs'],
        ['8', 'tuv'],
        ['9', 'wxyz']
    ]);

    // 结果集数组
    let res = [];
    // 回溯
    backtrack('', digits);
    return res;

    /**
     * 回溯函数
     * @param {*} curstr 当前路径已经拼接好的字符串
     * @param {*} digits 剩余字符串
     */
    function backtrack(curstr, digits) {
        if (digits.length === 0) {
            // 当前路径遍历结束了，将路径放入结果集
            res.push(curstr);
        } else {
            let str = map.get(digits.charAt(0)); //每次都取最前面的数字，去map中映射其字母
            for (let i = 0; i < str.length; i++) {
                // 拼接好当前路径，删掉当前处理的数字字符，继续回溯
                backtrack(curstr + str.charAt(i), digits.slice(1));
            }
        }
    }
};
```
<br/>



### [链表] 19.删除链表的倒数第N个节点
```
https://leetcode.cn/problems/remove-nth-node-from-end-of-list/
```

```
1.进行链表操作时，常用的一个技巧是添加一个哑节点
  它的next指针指向链表头结点，这样就不需要对头结点进行特殊判断了
2.方法：
    2.1 遍历计算链表长度；再次遍历删除对应节点
    2.2 栈结构 []
        - push() 入栈
        - pop() 出栈，得到出栈元素
    2.3 快慢指针[推荐] *
```

```javascript
/**
 * 方法一：计算链表长度
 *  先遍历一遍获取长度，再遍历一遍删除节点
 * 
 * 时间复杂度 O(n) n是链表长度
 * 空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    let first = new ListNode(0, head);
    // 统计链表长度
    let len = 0;
    while (head.next) {
        head = head.next;
        len++;
    }
    // 再次遍历，遍历至要删除的节点之前
    let cur = first;
    for (let i = 0; i < len - n + 1; i++) {
        cur = cur.next;
    }
    // 修改指针next
    cur.next = cur.next.next;
    return first.next;
};
```

```javascript
/**
 * 方法二：栈方法
 *  将所有节点元素都进栈，然后出栈倒数n个节点元素得到删除节点的前一个节点
 *  
 *  时间复杂度 O(n) 
 *  空间复杂度 O(n) 栈的开销
 * 
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    // 添加哑节点，指向链表第一个节点
    let first = new ListNode(0, head);
    let stack = []; //栈
    let cur = first;
    // 依次进栈
    while (cur !== null) {
        stack.push(cur);
        cur = cur.next;
    }
    // 出栈倒数n个节点
    for (let i = 0; i < n; ++i) {
        stack.pop();
    }
    // 得到要删除的节点的前一个节点，重新设置next指针
    let prev = stack.pop();
    prev.next = prev.next.next;
    // 返回头结点
    return first.next;
};
```

```javascript
/**
 * 方法三：双指针 快慢指针
 *  
 *  时间复杂度 O(n) 
 *  空间复杂度 O(1)
 * 
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    // 添加哑节点，指向链表第一个节点
    let first = new ListNode(0, head);
    let slow = first;
    let fast = first;
    // 快指针先走n步
    for (let i = 0; i < n; i++) {
        fast = fast.next;
    }
    // 快慢指针一起走
    while (fast.next !== null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;
    return first.next;
};
```
<br/>



### [数组|栈] 20.有效的括号
```
https://leetcode.cn/problems/valid-parentheses/
```

```javascript
/**
 * 解法：栈
 *  左括号入栈，右括号与栈顶匹配
 *  不是一对就返回false，是一对完成出栈
 * 
 * 时间复杂度 O(n)
 * 
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
    // 特判，奇数个必不可能有效
    if (s.length % 2 === 1) return false;
    // 符号映射关系
    let map = new Map();
    map.set(")", "(");
    map.set("]", "[");
    map.set("}", "{");
    // 栈
    let stack = [];
    for (let i = 0; i < s.length; i++) {
        if (!map.get(s.charAt(i))) {
            // 左半边，入栈
            stack.push(s.charAt(i));
        } else {
            // 右半边，看栈顶是否是一对
            if (stack[stack.length - 1] !== map.get(s.charAt(i))) {
                return false;
            }
            stack.pop();
        }
    }
    return stack.length === 0 ? true : false;
};
```
<br/>



### [链表] 21.合并两个有序链表
```
https://leetcode.cn/problems/merge-two-sorted-lists/
```

```
1. 方法一递归；方法二迭代。其实我本人有点分不清楚
    1.1 递归思路：
        新建哑节点，依次找两个链表头结点中的更小值，添加到这个新链表中
        直到两个链表都处理完
    1.2 迭代思路：
        新建哑节点，指向其中一个链表（假设是链表1），然后开始比较：
        在链表2中找比当前1中节点小的值插入进来；
        如果2>1，移动1的指针和prev（prev永远是p1.prev）
        直到处理完链表2，或者链表1遍历完了（直接把2接到1后面即可）
```

```javascript
/**
 * 方法一：递归
 *  新创建一个链表，找两个链表头节点更小值添加进来
 * 
 *  时间复杂度 O(m+n)
 *  空间复杂度 O(m+n)
 * 
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
    // 特判
    if (list1 === null) return list2;
    if (list2 === null) return list1;

    let p1 = list1;
    let p2 = list2;
    // 新建哑节点指向新的链表头
    let head = new ListNode(0);
    let prev = head;
    while (p1 || p2) {
        if (!p1) {
            // list1 没有后续节点了
            while (p2) {
                prev.next = new ListNode(p2.val);
                prev = prev.next;
                p2 = p2.next || null;
            }
        } else if (!p2) {
            // list2 没有后续节点了
            while (p1) {
                prev.next = new ListNode(p1.val);
                prev = prev.next;
                p1 = p1.next || null;
            }
        } else {
            if (p1.val <= p2.val) {
                prev.next = new ListNode(p1.val);
                p1 = p1.next || null;
            } else {
                prev.next = new ListNode(p2.val);
                p2 = p2.next || null;
            }
            prev = prev.next;
        }
    }
    return head.next;
};
```

```javascript
/**
 * 方法二：迭代
 * 
 * 时间复杂度 O(m+n)
 * 空间复杂度 O(1)
 * 
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
    // 特判
    if (list1 === null) return list2;
    if (list2 === null) return list1;

    // 新建哑节点指向第一个链表，相当于以第一个链表为基准
    let head = new ListNode(0, list1);
    let prev = head;
    let p1 = list1;
    let p2 = list2;

    // 依次移动指针，将第二个链表的更小节点添加进第一个链表直到无节点
    while (p2) {
        if (!p1) {
            // 如果第一个链表更早遍历完直接改变cur指针，然后退出while
            prev.next = p2;
            break;
        } else {
            if (p2.val <= p1.val) {
                let node = new ListNode(p2.val);
                node.next = p1;
                prev.next = node;
                prev = prev.next;
                p2 = p2.next;
            } else {
                p1 = p1.next || null;
                prev = prev.next;
            }
        }
    }
    return head.next;
};
```
<br/>



### [回溯] 22.括号生成
```
https://leetcode.cn/problems/generate-parentheses/
```

```
1.采用回溯法，感觉回溯法的写法有一丢丢像的，可以结合前面 (17) 题一起看看
    思路就是依次探索可以放左右括号的路径，直到左右括号被放完
    这个其实也可以用树的方式画出来解题思路
```

```javascript
/**
 * 回溯法
 * 
 * [思路]：
 *  因为括号是成对出现的，所以左括号数=右括号数=n
 *  初始化结果集，回溯过程就是依次找可能的结果直到n=0，然后放入结果集
 *  这个过程中，已有的左括号一定不能比右括号少，不然就不是有效括号了
 * 
 * 
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
    if (n === 0) return [];
    let res = []; //结果集
    backtrack('', n, n);
    return res;

    /**
     * 回溯函数
     * 
     * @param {*} cur 当前可能的结果（不一定完整）
     * @param {*} left 当前剩余左括号数量
     * @param {*} right 当前剩余右括号数量
     * @returns 
     */
    function backtrack(cur, left, right) {
        if (left === 0 && right === 0) {
            // 左右括号都放完了，放入结果集
            res.push(cur);
            return;
        }
        if (left === right) {
            // 左右括号数目相同，下一个必须放左括号
            backtrack(cur + '(', left - 1, right);
        } else if (left < right) {
            // 只要保证左边括号比右边多就好了，这种情况下，放左/右都行
            if (left > 0) {
                backtrack(cur + '(', left - 1, right);
            }
            if (right > 0) {
                backtrack(cur + ')', left, right - 1);
            }
        }
        // 没有right>left分支，因为那样括号无效了
    }
};
```
<br/>



### [链表数组] 24.合并K个升序链表
```
https://leetcode.cn/problems/merge-k-sorted-lists/
```

```
方法一：按顺序两两合并
方法二：分治
方法三：暴力法-数组(没写)
    将所有元素到一个数组中，然后对数组排序，再根据数组进行链表生成
    时间复杂度 O(NlogN) 这个是排序的时间
    空间复杂度 O(N)
```

```javascript
/**
 * 方法一：顺序合并
 *  按序，前后两两合并
 * 
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {
    let head = null;
    for (let i = 0; i < lists.length; i++) {
        head = sortTwoList(head, lists[i]);
    }
    return head;
};

function sortTwoList(list1, list2) {
    let head = new ListNode();
    let cur = head;
    while (list1 !== null && list2 !== null) {
        if (list1.val <= list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    cur.next = (list1 === null) ? list2 : list1;
    return head.next;
}
```

```javascript
/**
 * 方法二：分治
 * 
 * 时间复杂度 O(nlogk) k为链表总数 n为合并两个链表所用时间
 * 
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function (lists) {
    let n = lists.length;
    if (n == 0) return null;
    // 合并两个链表
    let mergeTwoLists = (l1, l2) => {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val <= l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
    let merge = (left, right) => {
        if (left == right) return lists[left];
        let mid = (left + right) >> 1; //相当于 /2
        let l1 = merge(left, mid);
        let l2 = merge(mid + 1, right);
        return mergeTwoLists(l1, l2);
    }
    return merge(0, n - 1);
};
```
<br/>



### [数组] 31.下一个排列
```
https://leetcode.cn/problems/next-permutation/
```

```
```

```javascript

```
<br/>



### [] 32.最长有效括号
```
```

```
```

```javascript

```
<br/>



### [数组] 33.搜索旋转排序数组
```
https://leetcode.cn/problems/search-in-rotated-sorted-array/
```

```
```

```javascript

```
<br/>



### [数组] 34.在排序数组中查找元素的第一个和最后一个位置
```
https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/
```

```
```

```javascript

```
<br/>



### [数组] 39.组合总和
```
https://leetcode.cn/problems/combination-sum/
```

```
```

```javascript

```
<br/>



### [数组] 42.接雨水
```
https://leetcode.cn/problems/trapping-rain-water/
```

```
```

```javascript

```
<br/>