- [[数组] 1.两数之和](#数组-1两数之和)
- [[链表] 2.两数相加](#链表-2两数相加)
- [[字符串] 3.无重复字符的最长子串(的长度)](#字符串-3无重复字符的最长子串的长度)
- [[数组] 4.寻找两个正序数组的中位数 (TODO)](#数组-4寻找两个正序数组的中位数-todo)
- [[数组] 88.合并两个有序数组](#数组-88合并两个有序数组)
- [[字符串] 5.最长回文子串](#字符串-5最长回文子串)
- [[数组] 11.盛最多水的容器](#数组-11盛最多水的容器)
- [[数组] 15.三数之和](#数组-15三数之和)
- [[] 17.电话号码的字母组合](#-17电话号码的字母组合)
- [[链表] 19.删除链表的倒数第N个节点](#链表-19删除链表的倒数第n个节点)
- [[数组] 20.有效的括号](#数组-20有效的括号)
- [[链表] 21.合并两个有序链表](#链表-21合并两个有序链表)
- [[] 22.括号生成](#-22括号生成)

<br/>

### [数组] 1.两数之和 
```
https://leetcode.cn/problems/two-sum/
```

```
1. 推荐方法一：利用 [哈希表] 减少再次遍历匹配
2. 拓展之ES6 Map的使用，特殊在于key可以是对象
    - size 属性
    - get(key)
        - 返回对应的值
    - set(key, value)
        - 注意：重复key会覆盖
        - 返回当前 Map 对象，因此可以链式调用
    - has(key): boolean
    - delete(key): boolean
    - clear(): void 清空
```

```TypeScript
/**
 * 方法一: 哈希表 [推荐，更优解] 只遍历一次
 * 
 * 时间复杂度 O(n)，空间复杂度 O(n) 哈希表开销
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 1. 初始化一个map<key, value>，key是数值，value是下标
    let map = new Map();

    /**
     * 2. 遍历每一个值：先找是否已有符合条件的另一个值在map中，有则直接返回，无则放入继续遍历
     */
    for (let i = 0; i < nums.length; i++) {
        // 找差值，也就是另一个数
        let otherValue = target - nums[i];
        if (map.has(otherValue)) {
            return [map.get(otherValue), i];
        } else {
            // 未找到符合条件的，先放入元素，继续遍历
            map.set(nums[i], i);
        }
    }
    // 未找到，返回空数组
    return [];
};
```
```TypeScript
/**
 * 方法二: 暴力枚举
 * 
 * 时间复杂度 O(n2)，空间复杂度 O(1)
 * 
 * @param {number[]} nums 输入数组
 * @param {number} target 目标值
 * @return {number[]} 结果下标数组
 */
function twoSum(nums: number[], target: number): number[] {
    // 双层遍历，直接看 num1 + num2 是否等于 target
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            // 里层遍历不需要从头遍历了
            if (nums[i] + nums[j] === target) {
                return [i, j];
            }
        }
    }
    return [];
};
```
<br/>



### [链表] 2.两数相加 
```
https://leetcode.cn/problems/add-two-numbers/
```

```
1. 注意链表新增节点的方式，遍历链表一般都是用while配合指针的移动，最后方法返回的是链表头结点
2. 两数相加一些老写的东西：
    - sum % 10，取模，计算出来的是个位数值，比如 (7+8) % 10 = 5
    - Math.floor(sum/10) 是计算进制位，Math.floor(15/10) = 1
```

```javascript
/**
 * 仔细观察就能看到，因为链表是逆序，所以直接链表从头结点开始进行相加进位即可
 * 需要注意的一个小点是对最后一位的处理
 * 
 * 时间复杂度 O(max(m,n))：m/n 分别为两个链表的长度，因为遍历链表的每个位置需要 O(1) 的时间
 * 空间复杂度 O(1) 返回值不计入空间复杂度
 * 
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    // 初始化结果链表的头结点、尾/当前节点
    let head = null, current = null;
    // 进制位
    let k = 0;

    // 遍历完两个链表无论谁长谁短
    while (l1 || l2) {
        let val1 = l1 ? l1.val || 0 : 0;
        let val2 = l2 ? l2.val || 0 : 0;

        // 算和
        let sum = val1 + val2 + k;

        // 计算进制，下一次计算时使用
        // k = (sum > 10) ? 1 : 0;
        k = Math.floor(sum / 10);

        // 取模，得到该节点的值；比如 7+8，value=5
        let value = sum % 10;
        // 新链表，无头结点
        if (!head) {
            head = current = new ListNode(value);
        } else {
            // 新增链表节点，移动指针
            current.next = new ListNode(value);
            current = current.next;
        }

        // 移动链表指针
        l1 = l1 && l1.next;
        l2 = l2 && l2.next;
    }

    // 链表结束遍历后处理可能的最后一位
    if (k > 0) {
        current.next = new ListNode(k);
    }

    // 返回链表头结点
    return head;
};

```
<br/>



### [字符串] 3.无重复字符的最长子串(的长度)
```
https://leetcode.cn/problems/longest-substring-without-repeating-characters/
```

```
1. 滑动窗口的应用，不仅限于这道题
2. 拓展补充 ES6 Set
    - size属性
    - add(value)
    - delete(value): boolean
    - has(value): boolean
    - clear()
3. 字符串获取某个位置上的字符：str.charAt(index)
```

```javascript
/**
 * 滑动窗口
 *  遍历每一个元素为其找到最大长度窗口（使用两个指针移动窗口），在每一次遍历后更新最大长度
 * 
 *  时间复杂度 O(n)
 * 
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    // 滑动窗口的右指针，左指针就是遍历字符串的指针
    let right = 0;
    // 最长长度，在针对每一个元素的窗口滑动之后都会去重新取新的最大值
    let max = 0;
    // 辅助判断是否有相同字符出现
    let set = new Set();

    // 依次遍历，找每一个元素的最大滑动窗口
    for (let left = 0; left < s.length; left++) {
        // 只要右指针未越界，元素未重复，就移动右指针并添加元素
        while (right < s.length && !set.has(s.charAt(right))) {
            set.add(s.charAt(right));
            right++;
        }
        // 重新计算最大长度
        max = Math.max(max, right - left);
        // 遍历结束，移除最左侧字符
        set.delete(s.charAt(left));
    }

    return max;
};
```
<br/>



### [数组] 4.寻找两个正序数组的中位数 (TODO)
```
https://leetcode.cn/problems/median-of-two-sorted-arrays/
```

```

```

```javascript

```
<br/>



### [数组] 88.合并两个有序数组
```
https://leetcode.cn/problems/merge-sorted-array/
```

```
从下到上说一下各个方法的优缺点:

[方法三]: 
    简单粗暴方法就是 [直接合并数组并再次排序]，
    当然不是最优解，而且也没有利用题目说的两个都是有序的，也没有利用到 nums1.length = m+n 的优势
[方法二]: 
    [双指针] 法利用了已经排序的优势，
    但是需要一个新的数组作为中间数组，
    而且最后因为题目要修改nums1，所以又需要再次把最后得到的数组再赋值到 nums1 里
[方法一]: 
    [逆向双指针] 是最优解了，因为既利用了已排序的优势，又是直接修改了 nums1，不需要额外空间

```

```javascript
/**
 * 
 * 方法一：逆向双指针
 * 
 * [思路]：
    这道题仔细审题会发现需要做的是直接修改 nums1 数组；
    其中的一个 [要点] 在于从后面开始修改数组，因为后面都是0补齐的；
    所以这道题有三个指针，分别初始化指向完整数组也就是 nums1 的尾部、nums1 有效数组尾部、nums2 有效数组尾部；
        这里操作指针：直接在操作完跟在后面减一，也就是先操作后--，无需单独写了
    还需要注意的一个点在于对于后两个指针的判断，因为有可能存在无有效数组的情况；
 * 
 * 
 * 时间复杂度 O(m+n) 因为指针至多移动 m+n 次
 * 空间复杂度 O(1) 因为是直接对 nums1 修改的
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    let k = m + n - 1;
    m--;
    n--;

    while (m >= 0 || n >= 0) {
        if (m === -1) {
            // 第一个数组无有效数字
            nums1[k--] = nums2[n--];
        } else if (n === -1) {
            // 第二个数组无有效数字
            nums1[k--] = nums1[m--];
        } else if (nums1[m] > nums2[n]) {
            // 前者数字更大，从后覆盖数组
            nums1[k--] = nums1[m--];
        } else {
            // 后者数字更大/两者相等都走这里逻辑
            nums1[k--] = nums1[n--];
        }
    }
};
```

```javascript
/**
 * 
 * 方法二：双指针
 * 
 * 
 *  时间复杂度 O(m+n) 指针移动至多 m+n 次
 *  空间复杂度 O(m+n) 需要长度为 m+n 长度的数组
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    // 初始化两个数组的指针，从头开始
    let p1 = 0, p2 = 0;
    let k = 0;
    // 一个中间数组
    let sorted = new Array(m + n).fill(0);

    // 双指针正向排序，依次取更小值放入
    while (p1 < m || p2 < n) {
        if (p1 === m) {
            // 第一个数组已经遍历完了，直接放第二个数组的元素
            sorted[k++] = nums2[p2++];
        } else if (p2 === n) {
            // 第二个数组已经历完了，直接放第一个数组的元素
            sorted[k++] = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            // 都未遍历完，前者小
            sorted[k++] = nums1[p1++];
        } else {
            // 后者小/相等
            sorted[k++] = nums2[p2++];
        }
    }

    // 把中间数组倒到 nums1 里
    for (let i = 0; i < sorted.length; i++) {
        nums1[i] = sorted[i];
    }
};
```

```javascript
/**
 * 
 * 方法三：简答粗暴 直接合并后排序
 * 
 *  1. splice(start, deleteCount [, item1 [, item2 [, ...]]])
 *      - 从下标 start 开始，删除 deleteCount 个数的元素；如果后面还有元素会添加进数组中
 * 
 *  时间复杂度 O((m+n)log(m+n)) 空间复杂度 O(log(m+n)) 直接套用快速排序的复杂度即可
 * 
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function (nums1, m, nums2, n) {
    // 从 m 下标开始删除 n 个元素，并添加 nums2 的各个元素
    nums1.splice(m, n, ...nums2);
    // 从小到大排序
    nums1.sort((a, b) => a - b);
};
```
<br/>



### [字符串] 5.最长回文子串
```
https://leetcode.cn/problems/longest-palindromic-substring/
```

```
1.首先先搞清楚 [回文子串] 是啥再答题：
    - 回文串是从左到右读和从右到左读都一样的字符串，有轴对称的特点
    - 子串：是指原始字符串的一个 [连续] 子集
        - 子序列：原始字符串的一个子集
2.这里只写了中心扩散法，还有其他方法：
    - 动态规划法（这个还挺常规解法的，但是我看不懂，之后再补吧）
    - Manacher算法（这个有难度）
```

```javascript
/**
 * 中心扩散法：
 *  [思想]:
 *      1. 遍历字符串的每一个字符，并将其作为子串的中点字符即中心，
 *      2. 以当前字符为中心向两边扩散：查找偶数回文子串和奇数回文子串
 *          2.1 偶数子串的中心位是2个数
 *          2.2 奇数子串的中心位是1个数
 *      3. 比较更新最大长度，记录中心位置下标
 *      4. 完成遍历后截取字符串（这个操作在确定了最长子串中心位后再整个方法最后执行就行，因为比较耗时）
 * 
 *  [注意]：中间那个分别求奇/偶回文子串其实也可以写成两个 while 分别算一下，然后比较最长长度再更新起始位置
 *          这样写的优势在于不用在计算起始位置时找规律
 * 
 * 
 *  时间复杂度 O(n2) 空间复杂度 O(1)
 * 
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function (s) {
    // 0.特殊判断
    let len = s.length;
    if (len < 2) return s;

    // 1. 初始化最长长度和子串开始位置下标
    let maxLen = 0;
    let begin = 0;

    // 2. 只需要判断到倒数第二个为止的元素即可
    for (let i = 0; i < len - 1; i++) {
        // 3.1 奇数回文串最长长度
        let [oddLen, oddLeft] = expandAroundCenter(s, i, i);
        // 3.2 偶数回文串最长长度
        let [evenLen, evenLeft] = expandAroundCenter(s, i, i + 1);

        // 4. 更新最长长度和子串起始下标
        let curMaxLen = Math.max(oddLen, evenLen);
        if (curMaxLen > maxLen) {
            maxLen = curMaxLen;
            begin = oddLen > evenLen ? oddLeft : evenLeft;
            // // 这里奇数偶数都可以用这个算式计算出起始位置， / 用来向下取整；
            // 不过我始终没明白怎么算出来的，所以我在辅助函数里直接返回回来
            // begin = i - (maxLen - 1) / 2;
        }
    }

    // 5. 截取字符串返回
    return s.slice(begin, begin + maxLen);
};

/**
 * 
 * 辅助函数：
 *  1.以传入的中心位下标，开始两边扩散找回文串，有两种情况：
 *    不过无论是哪种，第一步都可以直接进行左右比较，然后开始左右拓展
 *      1.1 -> left=right，中心位是同一个下标的元素，所以要找的是奇数回文串
 *      1.2 -> right=left+1，中心位是两个，找的是偶数回文串
 *  2.左右匹配相同就移动指针，一直到不相同了就退出 while 循环 (break 也可以退出 while 循环)
 *  3.返回子串长度和子串开始位置
 * 
 * @param s 字符串
 * @param left 左中心位下标
 * @param right 右中心位下标
 * @returns [length, begin]
 */
function expandAroundCenter(s, left, right) {
    while (left >= 0 && right < s.length && s.charAt(left) === s.charAt(right)) {
        left--;
        right++;
    }
    return [right - left - 1, left + 1];
}
```
<br/>



### [数组] 11.盛最多水的容器
```
https://leetcode.cn/problems/container-with-most-water/
```

```
- 理解题目：计算的盛水最多容器其实就是计算矩形面积的最大值，计算公式就是距离*min(h1,h2)
- 解题要点：双指针
- 解法：
    1.[双指针] 此题最优解：
        因为要计算的是矩形面积，
        而面积更大的条件无非是在控制一边的情况下，另一边越大越有可能成为更大的容器。
        所以基于这个想法移动短的边，寻找可能的更大面积，同样也是保留计算过程中的最大面积。
    2.[暴力解法] 没什么好说，依次计算所有面积，保留最大面积（这个提交没通过，超时了）
```

```javascript
/**
 * [双指针法] 此题最优解：
    因为要计算的是矩形面积，
    而面积更大的条件无非是在控制一边的情况下，另一边越大越有可能成为更大的容器。
    所以基于这个想法移动短的边，寻找可能的更大面积，同样也是保留计算过程中的最大面积。
 *  
 * 时间复杂度 O(n) 空间复杂度 O(1)
 * 
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let maxArea = 0;
    let len = height.length;
    let j = len - 1; //初始化右侧指针

    for (let i = 0; i < len - 1; i++) {
        // 两个指针相遇作为结束条件
        while (i < j) {
            maxArea = Math.max(
                maxArea,
                (j - i) * Math.min(height[i], height[j])
            );
            // 比较两边值的大小，移动更小的那一边，寻求更大面积解
            (height[i] > height[j]) ? j-- : i++;
        }
    }
    return maxArea;
};
```

```javascript
/**
 * 暴力解法：
 *  两次循环依次计算盛水面积，保留最大值
 * 
 * 时间复杂度 O(n2) 空间复杂度 O(1)
 * 
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
    let len = height.length;
    let maxArea = 0;
    for (let i = 0; i < len - 1; i++) {
        for (let j = i + 1; j < len; j++) {
            maxArea = Math.max(maxArea, (j - i) * Math.min(height[i], height[j]));
        }
    }
    return maxArea;
};
```
<br/>



### [数组] 15.三数之和
```
https://leetcode.cn/problems/3sum/
```

```
```

```javascript

```
<br/>



### [] 17.电话号码的字母组合
```
```

```
```

```javascript

```
<br/>



### [链表] 19.删除链表的倒数第N个节点
```
```

```
```

```javascript

```
<br/>



### [数组] 20.有效的括号
```
```

```
```

```javascript

```
<br/>



### [链表] 21.合并两个有序链表
```
```

```
```

```javascript

```
<br/>



### [] 22.括号生成
```
```

```
```

```javascript

```
<br/>